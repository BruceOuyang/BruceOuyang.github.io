---
title: 响应式编程01 - 从异步编程模型说起
thumbnail: https://upload-images.jianshu.io/upload_images/5792176-01ad974d8874fea0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
date: 2018-12-22 17:03
tags:
    - 响应式编程
categories:
    - 响应式编程
---

在ReactiveX社区的官网上，写着这么一句话，简单理解就是，ReactiveX用更好的方式为异步编程提供一套API接口。

可以看到，ReactiveX的核心使命是给开发者提供一套统一，好用的异步编程模型，而这也是RxJava受欢迎的最主要的原因之一，那么今天，我们就从异步编程模型谈起。看看到底什么是异步编程模型，异步编程到底面临怎样的困境。

## 一、什么异步编程模型

同步和异步的区别如下：
![同步和异步的区别](https://upload-images.jianshu.io/upload_images/5792176-3992615208d008ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 在同步执行时，当CPU执行到红色的IO任务时,，等待IO任务完成，直至IO完成，才继续执行接下来的普通任务；而在异步任务中，耗时操作在其他线程中，主线程不会被挂起。

作为开发者而言，并不希望自己的业务线程被挂起，阻塞。以Android开发为例，Android项目的主线程时不允许阻塞的，因为这回导致界面出现“假死”的状态，这对用户体验是极大的伤害。

因此，在编程语言或者系统中，为了防止主线程（业务线程）阻塞，就一定会为你提供异步的调用方法，可是，如果由我们自己全权处理异步操作，异步线程之间的通信的话，往往显得比较麻烦，因此，编程语言/框架还会**提供一套能够让你不用关心底层线程操作和通信的问题，可以很方便的写出异步执行代码编程方案**。这就异步编程模型。

总的来说，它是一套能够让你轻松处理异步操作的编码解决方案。

## 二、不同语言（系统）的异步模型

### 2.1 Java语言的异步操作模型
具体代码如下：

```java
    // 获取一个执行器
    ExecutorService executor = Executors.newCachedThreadPool();
    
    Future<String> future = executor.submit(new Callable(){
    // 提交之后立即执行
        System.out.println("running");
        Thread.sleep(3000);
        return "complete";
    });
   // 处理其他任务
    try {
      // 调用future.get() 获取执行结果(这居然是一个可能阻塞的调用！)
        System.out.println(future.get());  
    } catch (Exception e) {
    
    } finally {
        executor.shutdown();
    }
```

我们可以看到，虽然执行异步任务是相对简单的，但是获取异步结果却是一个大坑，因为调用future.get()的时候，它回去查看异步任务是否完成，如果完成，则返回结果，否则，就等待会任务完成。

由于这个模型大家可能比较陌生，我做了一个调用的示意图：
![Java的Future模型](https://upload-images.jianshu.io/upload_images/5792176-226acbc5c1b8bd5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> JDK8中，提供了CompletableFuture，这是对Future的扩展功能，帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合的方法。这也说明Java一直在想办法提供更好的异步操作模型。

### 2.2 Android系统提供的异步模型
在Android系统中，提供了AsyncTask这个异步编程模型（Android中也提供了Handler机制帮助我们很方便的自己实现一套异步操作），这些异步编程模型帮助我们处理异步的任务，而不用担心线程之间的在的一些问题。
```
private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {
    // 这个方法会在异步线程中执行
     protected Long doInBackground(URL... urls) {
         int count = urls.length;
         long totalSize = 0;
         for (int i = 0; i < count; i++) {
             totalSize += Downloader.downloadFile(urls[i]);
             publishProgress((int) ((i / (float) count) * 100));
             // Escape early if cancel() is called
             if (isCancelled()) break;
         }
         return totalSize;
     }
    // 在异步线程执行，会定时在主线程中调用
     protected void onProgressUpdate(Integer... progress) {
     // 展示进度条
         setProgressPercent(progress[0]);
     }
    // 在异步线程执行完成之后，在主线程中被调用
     protected void onPostExecute(Long result) {
     // 展示对话框，提示用户下载完成
         showDialog("Downloaded " + result + " bytes");
     }
     // 在异步线程被调用之前，会在主线程调用这个方法
     protected void onPreExecute(){
         
     }
 }
 
 //开启这个异步任务很简单，获取DownloadFilesTask对象实例，执行execute方法
  new DownloadFilesTask().execute(url1, url2, url3);
```

这是Android封装给我们的一个异步编程模型，可能某些同学对于Android开发不太了解，我对这段代码做了一个调用模型的示意图：
![Android的异步编程模型](https://upload-images.jianshu.io/upload_images/5792176-c638b3cb8639a8ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 三、小结
可以看到，Android提供的异步编程模型相对于Java更加完善，主线程没有阻塞的风险，可以说，这是一个不错的异步编程模式。

可是因为这套异步模型对于线程的抽象程度还不够，所以我们很难用它处理复杂的业务逻辑。比如，我现在需要两个完全不同异步任务完成之后，再提示用户操作已完成。这就很难处理，通常情况下，我们的处理方法是在一个线程里依次完成两个不同的耗时任务，但这显然不是最好的解决方案。

> 由于Java和Android两者的地位不同，关注点也会有所差异，因此它们提供的异步编程模型在设计和使用上都是不同的。但是总的来说，他们都没有提供一个相对完美的异步编程模型。

### 3.1 异步编程模型存在的问题
讲到这里，我们应该能够了解，无论是编程语言还是系统，所能提供的异步编程模型都存在一些问题：

某些模型不完善，依然会导致阻塞的风险
对于线程，同步等问题的抽象不够，导致无法应对复杂业务逻辑
在异步代码的编写上，也不如同步代码那样容易理解

### 3.2 异步编程的新方案？
正是因为在编程语言和系统中存在许多困境，因此大家都在探索一种更好的异步编程模型，ReactiveX就是其中一个，而且可能是目前Java世界里最好的解决方案之一。

而且ReactiveX只是一套异步编程的API，而不是具体的实现，因此它具备在不同的编程语言平台提供统一的异步操作风格和代码体验的能力。

那么，ReactiveX到底是如何一步步解决我们的异步编程困境的呢？

这个问题，请听下周再来分解。