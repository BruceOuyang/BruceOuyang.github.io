{"meta":{"title":"BuGMaker' Bruce Ouyang","subtitle":null,"description":null,"author":"Bruce Ouyang","url":"http://bruce.bugmakers.club"},"pages":[{"title":"关于","date":"2018-04-19T06:13:36.000Z","updated":"2019-01-03T16:09:26.625Z","comments":true,"path":"about/index.html","permalink":"http://bruce.bugmakers.club/about/index.html","excerpt":"","text":"BuGMakersClub希望有想法的小伙伴们可以集结在一起，让所做的事情变得更有价值。 如果你对 BuGMakersClub 感兴趣，可以加我们的QQ群 111915819。 我我叫布鲁斯(Bruce)，一个简单的程序员。 Head Of BuGMakers"},{"title":"Categories","date":"2018-04-19T13:55:28.560Z","updated":"2018-04-17T23:19:52.693Z","comments":true,"path":"categories/index.html","permalink":"http://bruce.bugmakers.club/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-19T13:55:28.566Z","updated":"2018-04-17T23:19:52.693Z","comments":true,"path":"tags/index.html","permalink":"http://bruce.bugmakers.club/tags/index.html","excerpt":"","text":""},{"title":"我的简历| 2018版 | 欧阳强强 | 176-0212-5174 | Java高级工程师 | 6年工作经验","date":"2019-01-06T03:55:49.052Z","updated":"2019-01-06T03:55:49.045Z","comments":true,"path":"about/resume.html","permalink":"http://bruce.bugmakers.club/about/resume.html","excerpt":"","text":"联系方式 手机：17602125174 Email：oiiopro@live.cn QQ：1276541098 微信号：oiiopro 个人信息 欧阳强强(Bruce Ouyang) / 男 / 1992 专科 / 长沙学院 / 计算机应用技术 工作年限：6年 期望职位：Java高级程序员，架构师 期望薪资：面议 期望城市：上海 CSDN：https://blog.csdn.net/boybruce Github：http://github.com/bruceouyang 个人博客：http://bruceouyang.github.io 工作经历宝德融资租赁 （ 2018年5月 ~ 至今 ）德易车金融项目 做的比较出色： 最困难的问题： 当时解决方式： 其他总结： 掘新科技(上海)有限公司 （ 2015年8月 ~ 2018年4月 ）海银基金平台项目（互联网金融） 做的比较出色：对系统分析文档整理的比较清晰，帮助同事熟悉业务和系统更顺利。 最困难的问题：刚上手的时候没有任何文档，给team成员带来了极大的困扰。 当时解决方式：我在熟悉项目的过程中，及时记录我看过的内容并整理成文档，然后分享给我的同事，并且把这个方法也推荐给他们。 其他总结：在项目过程中发现team管理不是很合理，跟领导沟通并推荐使用半敏捷的模式来做团队管理，得到了领导的认同。 博泰PAAS云平台项目（车联网） 做的比较出色：积极配合领导的工作，有问题及时沟通，能够按时按量的完成领导安排的工作。 最困难的问题：有很多没用过的新技术，如springboot、springcloud、zk、kafka。 当时解决方式：上官网找api文档学习、快速精准的阅读网上的博客，在github&amp;gitee上找相关源码学习。 其他总结：在这个项目中，我最自豪的是短时间内学习了很多新东西，还做了一回讲师，内部分享了《SpringCloud任务跟踪服务Sleuth组件》，在当年收到了公司发的教师节礼物。 德晟资本财富农场项目（互联网金融） 做的比较出色：积极配合领导的工作，有问题及时沟通，能够按时按量的完成领导安排的工作。 最困难的问题： 当时解决方式： 其他总结： 文聪信息科技有限公司 （ 2012年9月 ~ 2015年8月 ）艾特网车载WiFi项目 做的比较出色：对业务了解的比较彻底，跟多个三方公司对接都比较顺利 最困难的问题： 当时解决方式： 其他总结：这个项目中，我最自豪的是，第一次去IDC机房装机，独自完成系统搭建和软件部署，第一次担任公司技术负责人，获得了公司首席java工程师的title、获得了年度优秀个人称号 MIS系统 做的比较出色的是：跟各部门负责人沟通需求很顺利、研发小组管理有条不紊 最困难的问题： 当时解决方式： 其他总结： 艾思特科技（上海）有限公司 （ 2011年11月 ~ 2012年9月 ）TMS项目二次开发 做的比较出色的是：对业务的理解比较好，SQL写的还不错 最困难的问题： 当时解决方式： 其他总结： 技能清单 前端：html、jsp、css、js、jQuery、EasyUI等 后端：Servlet、Struts、Spring、SpringMVC、Hibernate、iBatis、MyBatis、Netty等 数据库：MSSQL、Oracle、MySQL、MongoDB WEB服务器：Tomcat、Jetty、Websphere、Nginx 服务器操作系统：WindowServer、Linux（Redhat、Centos、Ubuntu） 分布式相关: SpringCloud、Dubbo、Zookeeper、Memcached、Kafka、Redis等 开发环境：jdk1.6、jdk1.7、jdk1.8 开发工具：Eclipse、MyEclipse、 Idea 版本管理：Git、SVN 项目构建：Maven 文档：swagger、jdoc、oscteam 荣誉 2018年 获得公司《期权授予证书》 / 宝德融资租赁 2014年 获得公司《先进个人证书》 / 文聪科技 其他教育经历 长沙学院 (2014年2月 ~ 2016年6月) / 计算机应用技术专业 / 大专文凭 欧博泰克计算机学院 (2009年7月 ~ 2011年11月) / 计算机基础和软件开发 / 中级程序员证书 培训经历 网易微专业 / Java高级开发工程师 (2018年12月 ~ 2019年12月) / 进行中 上海市人力资源和社会保障局 (2014年9月 ~ 2015年3月) / JAVA（高级）培训 / 高级Java工程师证书 华尔街英语SH14 (2012年6月 ~ 2015年3月) / 英语口语培训课程 / 华尔街英语T1级别证书 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"}],"posts":[{"title":"JAVA基础 | JAVA程序运行原理分析","slug":"java/base/JAVA程序运行原理分析","date":"2019-01-07T16:00:00.000Z","updated":"2019-01-08T17:36:04.817Z","comments":true,"path":"2019/01/08/java/base/JAVA程序运行原理分析/","link":"","permalink":"http://bruce.bugmakers.club/2019/01/08/java/base/JAVA程序运行原理分析/","excerpt":"","text":"Java程序的运行，首先会将源码文件(.java)编译成Class文件(.class)，进而jvm会去解析class文件，将其解释为操作系统可识别的指令进行运算。 JVM 运行时数据区 线程独占：每个线程都会有它独立的空间，随线程生命周期而创建和销毁 线程共享：所有线程能访问这块内存数据，随虚拟机或者GC而创建和销毁 方法区 方法区，JVM用来存储加载的：类、常量、静态变量、编译后的代码等数据。 虚拟机规范中这是一个逻辑划分区，具体实现根据不同虚拟机来实现。 如：oracle的HotSpot在java7中方法区放在永久代，java8放在元数据空间，并且通过GC机制对这个区域进行管理 堆内存 堆内存，还可以细分为：老年代、新生代(Eden、From Survivor、To Survivor)。 JVM启动是创建，存放对象的实例。垃圾回收器主要就是管理堆内存。 如果满了，就会出现OutOfMemoryError。 虚拟机栈 虚拟机栈，是为虚拟机执行JAVA方法而准备的。 每个线程在这个空间有一个私有空间，线程栈由多个栈帧(Stack Frame)组成。 一个线程会执行一个或多个方法，一个方法对应一个栈帧。 栈帧内容包含：局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。 栈内存默认最大是1MB，超出则抛出StackOverflowError。 本地方法栈 本地方法栈，是为虚拟机使用Native本地方法而准备的。 虚拟机规范没有规定具体的实现，由不同的虚拟机厂商去实现。 HotSpot虚拟机中虚拟机栈和本地方法栈的实现是一样的。同样，超出大小则抛出StackOverflowError。 程序计数器 程序计数器(Program Counter Register)，记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行Native方法，则计数器值为空。 每个线程都在这个空间有一个私有空间，占用内存空间很少。 CPU同一时间，只会执行一条线程中的指令。JVM多线程会轮流切换并分配CPU执行时间的方式。为了线程切换后，需要通过程序计数器来恢复正确的执行位置。 class 文件内容class文件包含JAVA程序执行的字节码；数据严格按照格式紧凑排列在class文件中的二进制流，中间无任何分隔符；文件开头有一个0xcafebabe(16进制)特殊的一个标志。 查看class文件内容准备一个java文件，例如：123456789public class Demo1 &#123; public static void main(String[] args) &#123; int x = 500; int y = 100; int a = x / y; int b = 50; System.out.println(a + b); &#125;&#125; 使用命令 javac 来编译一个 .java 文件，编译成功之后会生成一个 .class 文件，例如：1javac Demo1.java 使用命令 javap 来解析一个 .class 文件，会输出解析结果，我们可以将解析结果保存在一个 .txt 文件中，例如：1javap -v Demo1.class&gt;Demo1.txt class内容 - 版本号/访问标识javap输出内容摘要：12345public class club.bugmakers.boyneteasejava.demo.Demo1 minor version: 0 //次版本号 major version: 52 //主版本号 flags: ACC_PUBLIC, ACC_SUPER //访问标志 ... 版本号规则：JDK5,6,7,8分别对应49,50,51,52 访问标志： class内容 - 常量池javap输出内容摘要：123456789101112131415161718192021222324252627Constant pool: #1 = Methodref #5.#14 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #15.#16 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #17.#18 // java/io/PrintStream.println:(I)V #4 = Class #19 // club/bugmakers/boyneteasejava/demo/Demo1 #5 = Class #20 // java/lang/Object #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 main #11 = Utf8 ([Ljava/lang/String;)V #12 = Utf8 SourceFile #13 = Utf8 Demo1.java #14 = NameAndType #6:#7 // &quot;&lt;init&gt;&quot;:()V #15 = Class #21 // java/lang/System #16 = NameAndType #22:#23 // out:Ljava/io/PrintStream; #17 = Class #24 // java/io/PrintStream #18 = NameAndType #25:#26 // println:(I)V #19 = Utf8 club/bugmakers/boyneteasejava/demo/Demo1 #20 = Utf8 java/lang/Object #21 = Utf8 java/lang/System #22 = Utf8 out #23 = Utf8 Ljava/io/PrintStream; #24 = Utf8 java/io/PrintStream #25 = Utf8 println #26 = Utf8 (I)V 类信息包含的静态常量，编译之后就能确认，比如：类的名称、方法名称。 常量池常见类型： class内容 - 构造方法javap输出内容摘要：12345678910public club.bugmakers.boyneteasejava.demo.Demo1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 10: 0 Demo1这个示例中，我们并没有写构造函数。 由此可见，没有定义构造函数时，会有隐式的无参构造函数。 class内容 - 程序入口main方法 JVM指令码表 程序完整运行分析加载信息到方法区 JVM创建线程来执行代码 线程独占空间和执行指令码 …依次执行，直到最后一个字节码指令执行完成 总结本文对JVM运行的核心逻辑进行了详细剖析。 注意： JVM运行原理中更底层实现，针对不同的操作系统或者处理器，会有不同的实现。 这也是JAVA能够实现“一处编写，到处运行”的原因。 开发人员理解到这个层次，就足够学习掌握多线程的相关知识了。","categories":[{"name":"java","slug":"java","permalink":"http://bruce.bugmakers.club/categories/java/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"http://bruce.bugmakers.club/tags/JAVA基础/"},{"name":"JAVA高性能编程","slug":"JAVA高性能编程","permalink":"http://bruce.bugmakers.club/tags/JAVA高性能编程/"},{"name":"网易微专业","slug":"网易微专业","permalink":"http://bruce.bugmakers.club/tags/网易微专业/"},{"name":"运行原理","slug":"运行原理","permalink":"http://bruce.bugmakers.club/tags/运行原理/"}]},{"title":"awesome | 规则引擎 - QLExpress","slug":"awesome/QLExpress","date":"2018-12-22T09:03:00.000Z","updated":"2019-01-08T15:07:02.636Z","comments":true,"path":"2018/12/22/awesome/QLExpress/","link":"","permalink":"http://bruce.bugmakers.club/2018/12/22/awesome/QLExpress/","excerpt":"","text":"一、简介QlExpress脚本语言解析工具诞生于2010年，是玄难大师根据当时汇金的业务需要开始编写。 该项目是由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。 QlExpress经过40多个小版本的迭代，性能和功能更加趋于稳定，被更多的团队接受和认可，在双11洪流高峰、复杂规则业务配置平台等场景下也得到更好的实战考验。 开源地址：https://github.com/alibaba/QLExpress 二、使用1、 依赖和调用说明maven 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;QLExpress&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 简单示例12345678ExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();context.put(&quot;a&quot;,1);context.put(&quot;b&quot;,2);context.put(&quot;c&quot;,3);String express = &quot;a+b*c&quot;;Object r = runner.execute(express, context, null, true, false);System.out.println(r); 2、语法介绍2.1 操作符和 java 对象操作普通 Java 语法12345678910111213//支持 +,-,*,/,&lt;,&gt;,&lt;=,&gt;=,==,!=,&lt;&gt;【等同于!=】,%,mod【取模等同于%】,++,--,//in【类似sql】,like【sql语法】,&amp;&amp;,||,!,等操作符//支持for，break、continue、if then else 等标准的程序控制逻辑n=10;for(sum=0,i=0;i&lt;n;i++)&#123;sum=sum+i;&#125;return sum; //逻辑三元操作a=1;b=2;max = a&gt;b?a:b; Java 的对象操作12345678import com.ql.util.express.test.OrderQuery;//系统自动会import java.lang.*,import java.util.*;query = new OrderQuery();//创建class实例,会根据classLoader信息，自动补全类路径query.setCreateDate(new Date());//设置属性query.buyer = &quot;张三&quot;;//调用属性,默认会转化为setBuyer(&quot;张三&quot;)result = bizOrderDAO.query(query);//调用bean对象的方法System.out.println(result.getId());//静态方法 2.2 脚本中定义function12345678910function add(int a,int b)&#123; return a+b;&#125;;function sub(int a,int b)&#123; return a - b;&#125;;a=10;return add(a,4) + sub(a,9); 2.3 扩展操作符：Operator替换if then else 等关键字1234567runner.addOperatorWithAlias(&quot;如果&quot;, &quot;if&quot;,null);runner.addOperatorWithAlias(&quot;则&quot;, &quot;then&quot;,null);runner.addOperatorWithAlias(&quot;否则&quot;, &quot;else&quot;,null);exp = &quot;如果 (语文+数学+英语&gt;270) 则 &#123;return 1;&#125; 否则 &#123;return 0;&#125;&quot;;DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.execute(exp,context,null,false,false,null); 如何自定义Operator12345678910111213141516//定义一个继承自com.ql.util.express.Operator的操作符public class JoinOperator extends Operator&#123; public Object executeInner(Object[] list) throws Exception &#123; Object opdata1 = list[0]; Object opdata2 = list[1]; if(opdata1 instanceof java.util.List)&#123; ((java.util.List)opdata1).add(opdata2); return opdata1; &#125;else&#123; java.util.List result = new java.util.ArrayList(); result.add(opdata1); result.add(opdata2); return result; &#125; &#125;&#125; 如何使用Operator1234567891011121314151617181920212223//(1)addOperatorExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.addOperator(&quot;join&quot;,new JoinOperator());Object r = runner.execute(&quot;1 join 2 join 3&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3]//(2)replaceOperatorExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.replaceOperator(&quot;+&quot;,new JoinOperator());Object r = runner.execute(&quot;1 + 2 + 3&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3]//(3)addFunctionExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.addFunction(&quot;join&quot;,new JoinOperator());Object r = runner.execute(&quot;join(1,2,3)&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3] 2.4 绑定java类或者对象的methodaddFunctionOfClassMethod + addFunctionOfServiceMethod123456789101112131415161718192021222324252627public class BeanExample &#123; public static String upper(String abc) &#123; return abc.toUpperCase(); &#125; public boolean anyContains(String str, String searchStr) &#123; char[] s = str.toCharArray(); for (char c : s) &#123; if (searchStr.contains(c+&quot;&quot;)) &#123; return true; &#125; &#125; return false; &#125;&#125;runner.addFunctionOfClassMethod(&quot;取绝对值&quot;, Math.class.getName(), &quot;abs&quot;, new String[] &#123; &quot;double&quot; &#125;, null);runner.addFunctionOfClassMethod(&quot;转换为大写&quot;, BeanExample.class.getName(), &quot;upper&quot;, new String[] &#123; &quot;String&quot; &#125;, null);runner.addFunctionOfServiceMethod(&quot;打印&quot;, System.out, &quot;println&quot;,new String[] &#123; &quot;String&quot; &#125;, null);runner.addFunctionOfServiceMethod(&quot;contains&quot;, new BeanExample(), &quot;anyContains&quot;, new Class[] &#123; String.class, String.class &#125;, null);String exp = “取绝对值(-100);转换为大写(\\&quot;hello world\\&quot;);打印(\\&quot;你好吗？\\&quot;);contains(&quot;helloworld&quot;,\\&quot;aeiou\\&quot;)”;runner.execute(exp, context, null, false, false); 2.5 macro 宏定义123456789runner.addMacro(&quot;计算平均成绩&quot;, &quot;(语文+数学+英语)/3.0&quot;);runner.addMacro(&quot;是否优秀&quot;, &quot;计算平均成绩&gt;90&quot;);IExpressContext&lt;String, Object&gt; context =new DefaultContext&lt;String, Object&gt;();context.put(&quot;语文&quot;, 88);context.put(&quot;数学&quot;, 99);context.put(&quot;英语&quot;, 95);Object result = runner.execute(&quot;是否优秀&quot;, context, null, false, false);System.out.println(r);//返回结果true 2.6 编译脚本，查询外部需要定义的变量和函数 注意以下脚本int和没有int的区别12345678910111213String express = &quot;int 平均分 = (语文+数学+英语+综合考试.科目2)/4.0;return 平均分&quot;;ExpressRunner runner = new ExpressRunner(true,true);String[] names = runner.getOutVarNames(express);for(String s:names)&#123; System.out.println(&quot;var : &quot; + s);&#125;//输出结果：var : 数学var : 综合考试var : 英语var : 语文 2.7 关于不定参数的使用12345678910111213141516171819202122@Test public void testMethodReplace() throws Exception &#123; ExpressRunner runner = new ExpressRunner(); IExpressContext&lt;String,Object&gt; expressContext = new DefaultContext&lt;String,Object&gt;(); runner.addFunctionOfServiceMethod(&quot;getTemplate&quot;, this, &quot;getTemplate&quot;, new Class[]&#123;Object[].class&#125;, null); //(1)默认的不定参数可以使用数组来代替 Object r = runner.execute(&quot;getTemplate([11,&apos;22&apos;,33L,true])&quot;, expressContext, null,false, false); System.out.println(r); //(2)像java一样,支持函数动态参数调用,需要打开以下全局开关,否则以下调用会失败 DynamicParamsUtil.supportDynamicParams = true; r = runner.execute(&quot;getTemplate(11,&apos;22&apos;,33L,true)&quot;, expressContext, null,false, false); System.out.println(r); &#125; //等价于getTemplate(Object[] params) public Object getTemplate(Object... params) throws Exception&#123; String result = &quot;&quot;; for(Object obj:params)&#123; result = result+obj+&quot;,&quot;; &#125; return result; &#125; 2.8 关于集合的快捷写法1234567891011121314@Testpublic void testSet() throws Exception &#123; ExpressRunner runner = new ExpressRunner(false,false); DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;(); String express = &quot;abc = NewMap(1:1,2:2); return abc.get(1) + abc.get(2);&quot;; Object r = runner.execute(express, context, null, false, false); System.out.println(r); express = &quot;abc = NewList(1,2,3); return abc.get(1)+abc.get(2)&quot;; r = runner.execute(express, context, null, false, false); System.out.println(r); express = &quot;abc = [1,2,3]; return abc[1]+abc[2];&quot;; r = runner.execute(express, context, null, false, false); System.out.println(r);&#125; 2.9 集合的遍历其实类似java的语法，只是ql不支持for(obj:list){}的语法，只能通过下标访问12345678910//遍历map map = new HashMap(); map.put(&quot;a&quot;, &quot;a_value&quot;); map.put(&quot;b&quot;, &quot;b_value&quot;); keySet = map.keySet(); objArr = keySet.toArray(); for (i=0;i&lt;objArr.length;i++) &#123; key = objArr[i]; System.out.println(map.get(key)); &#125; 3、运行参数和API列表介绍QLExpressRunner如下图所示，从语法树分析、上下文、执行过程三个方面提供二次定制的功能扩展。 3.1 属性开关isPrecise1234/** * 是否需要高精度计算 */private boolean isPrecise = false; 高精度计算在会计财务中非常重要，java的float、double、int、long存在很多隐式转换，做四则运算和比较的时候其实存在非常多的安全隐患。 所以类似汇金的系统中，会有很多BigDecimal转换代码。而使用QLExpress，你只要关注数学公式本身 订单总价 = 单价 数量 + 首重价格 + （ 总重量 - 首重） 续重单价 ，然后设置这个属性即可，所有的中间运算过程都会保证不丢失精度。 isShortCircuit1234/** * 是否使用逻辑短路特性 */private boolean isShortCircuit = true; 在很多业务决策系统中，往往需要对布尔条件表达式进行分析输出，普通的java运算一般会通过逻辑短路来减少性能的消耗。例如规则公式： star&gt;10000 and shoptype in(‘tmall’,’juhuasuan’) and price between (100,900) 假设第一个条件 star&gt;10000 不满足就停止运算。但业务系统却还是希望把后面的逻辑都能够运算一遍，并且输出中间过程，保证更快更好的做出决策。 参照单元测试: ShortCircuitLogicTest.java isTrace1234/** * 是否输出所有的跟踪信息，同时还需要log级别是DEBUG级别 */private boolean isTrace = false; 这个主要是是否输出脚本的编译解析过程，一般对于业务系统来说关闭之后会提高性能。 3.2 调用入参123456789101112/** * 执行一段文本 * @param expressString 程序文本 * @param context 执行上下文，可以扩展为包含ApplicationContext * @param errorList 输出的错误信息List * @param isCache 是否使用Cache中的指令集,建议为true * @param isTrace 是否输出详细的执行指令信息，建议为false * @param aLog 输出的log * @return * @throws Exception */Object execute(String expressString, IExpressContext&lt;String,Object&gt; context,List&lt;String&gt; errorList, boolean isCache, boolean isTrace, Log aLog); 3.3 功能扩展API列表QLExpress主要通过子类实现Operator.java提供的以下方法来最简单的操作符定义，然后可以被通过addFunction或者addOperator的方式注入到ExpressRunner中。1public abstract Object executeInner(Object[] list) throws Exception; 比如我们几行代码就可以实现一个功能超级强大、非常好用的join操作符:list = 1 join 2 join 3; -&gt; [1,2,3] list = join(list,4,5,6); -&gt; [1,2,3,4,5,6]123456789101112131415public class JoinOperator extends Operator&#123; public Object executeInner(Object[] list) throws Exception &#123; java.util.List result = new java.util.ArrayList(); Object opdata1 = list[0]; if(opdata1 instanceof java.util.List)&#123; result.addAll((java.util.List)opdata1); &#125;else&#123; result.add(opdata1); &#125; for(int i=1;i&lt;list.length;i++)&#123; result.add(list[i]); &#125; return result; &#125;&#125; 如果你使用Operator的基类OperatorBase.java将获得更强大的能力，基本能够满足所有的要求。 3.3.1 function相关API12345678910111213141516//通过name获取function的定义OperatorBase getFunciton(String name);//通过自定义的Operator来实现类似：fun(a,b,c)void addFunction(String name, OperatorBase op);//fun(a,b,c) 绑定 object.function(a,b,c)对象方法void addFunctionOfServiceMethod(String name, Object aServiceObject, String aFunctionName, Class&lt;?&gt;[] aParameterClassTypes, String errorInfo);//fun(a,b,c) 绑定 Class.function(a,b,c)类方法void addFunctionOfClassMethod(String name, String aClassName, String aFunctionName, Class&lt;?&gt;[] aParameterClassTypes, String errorInfo);//给Class增加或者替换method，同时 支持a.fun(b) ，fun(a,b) 两种方法调用//比如扩展String.class的isBlank方法:“abc”.isBlank()和isBlank(&quot;abc&quot;)都可以调用void addFunctionAndClassMethod(String name,Class&lt;?&gt;bindingClass, OperatorBase op); 3.3.2 Operator相关API提到脚本语言的操作符，优先级、运算的目数、覆盖原始的操作符(+,-,*,/等等)都是需要考虑的问题，QLExpress统统帮你搞定了。123456789//添加操作符号,可以设置优先级void addOperator(String name,Operator op);void addOperator(String name,String aRefOpername,Operator op); //替换操作符处理OperatorBase replaceOperator(String name,OperatorBase op); //添加操作符和关键字的别名，比如 if..then..else -&gt; 如果。。那么。。否则。。void addOperatorWithAlias(String keyWordName, String realKeyWordName, String errorInfo); 3.3.3 宏定义相关APIQLExpress的宏定义比较简单，就是简单的用一个变量替换一段文本，和传统的函数替换有所区别。12//比如addMacro(&quot;天猫卖家&quot;,&quot;userDO.userTag &amp;1024 ==1024&quot;)void addMacro(String macroName,String express) 3.3.4 java class的相关apiQLExpress可以通过给java类增加或者改写一些method和field，比如 链式调用：”list.join(“1”).join(“2”)”，比如中文属性：”list.长度”。12345//添加类的属性字段void addClassField(String field,Class&lt;?&gt;bindingClass,Class&lt;?&gt;returnType,Operator op);//添加类的方法void addClassMethod(String name,Class&lt;?&gt;bindingClass,OperatorBase op); 注意，这些类的字段和方法是执行器通过解析语法执行的，而不是通过字节码增强等技术，所以只在脚本运行期间生效，不会对jvm整体的运行产生任何影响，所以是绝对安全的。 3.3.5 语法树解析变量、函数的API这些接口主要是对一个脚本内容的静态分析，可以作为上下文创建的依据，也可以用于系统的业务处理。比如：计算 “a+fun1(a)+fun2(a+b)+c.getName()” 包含的变量:a,b,c 包含的函数:fun1,fun21234//获取一个表达式需要的外部变量名称列表String[] getOutVarNames(String express);String[] getOutFunctionNames(String express); 3.3.6 语法解析校验api脚本语法是否正确，可以通过ExpressRunner编译指令集的接口来完成。123String expressString = &quot;for(i=0;i&lt;10;i++)&#123;sum=i+1&#125;return sum;&quot;;InstructionSet instructionSet = expressRunner.parseInstructionSet(expressString);//如果调用过程不出现异常，指令集instructionSet就是可以被加载运行（execute）了！ 3.3.7 指令集缓存相关的api因为QLExpress对文本到指令集做了一个本地HashMap缓存，通常情况下一个设计合理的应用脚本数量应该是有限的，缓存是安全稳定的，但是也提供了一些接口进行管理。1234//优先从本地指令集缓存获取指令集，没有的话生成并且缓存在本地InstructionSet getInstructionSetFromLocalCache(String expressString);//清除缓存void clearExpressCache(); 3.3.8 增强上下文参数Context相关的api - 01与spring框架的无缝集成上下文参数 IExpressContext context 非常有用，它允许put任何变量，然后在脚本中识别出来。在实际中我们很希望能够无缝的集成到spring框架中，可以仿照下面的例子使用一个子类。1234567891011121314151617181920212223242526272829303132333435public class QLExpressContext extends HashMap&lt;String, Object&gt; implements IExpressContext&lt;String, Object&gt; &#123; private ApplicationContext context; //构造函数，传入context和 ApplicationContext public QLExpressContext(Map&lt;String, Object&gt; map, ApplicationContext aContext) &#123; super(map); this.context = aContext; &#125; /** * 抽象方法：根据名称从属性列表中提取属性值 */ public Object get(Object name) &#123; Object result = null; result = super.get(name); try &#123; if (result == null &amp;&amp; this.context != null &amp;&amp; this.context.containsBean((String) name)) &#123; // 如果在Spring容器中包含bean，则返回String的Bean result = this.context.getBean((String) name); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return result; &#125; public Object put(String name, Object object) &#123; return super.put(name, object); &#125;&#125; 完整的demo参照 SpringDemoTest.java 3.3.9 增强上下文参数Context相关的api - 02自定义函数操作符获取原始的context控制上下文自定义的Operator需要直接继承OperatorBase，获取到parent即可，可以用于在运行一组脚本的时候，直接编辑上下文信息，业务逻辑处理上也非常有用。12345678910111213141516171819202122232425262728293031public class ContextMessagePutTest &#123; class OperatorContextPut extends OperatorBase &#123; public OperatorContextPut(String aName) &#123; this.name = aName; &#125; @Override public OperateData executeInner(InstructionSetContext parent, ArraySwap list) throws Exception &#123; String key = list.get(0).toString(); Object value = list.get(1); parent.put(key,value); return null; &#125; &#125; @Test public void test() throws Exception&#123; ExpressRunner runner = new ExpressRunner(); OperatorBase op = new OperatorContextPut(&quot;contextPut&quot;); runner.addFunction(&quot;contextPut&quot;,op); String exp = &quot;contextPut(&apos;success&apos;,&apos;false&apos;);contextPut(&apos;error&apos;,&apos;错误信息&apos;);contextPut(&apos;warning&apos;,&apos;提醒信息&apos;)&quot;; IExpressContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;(); context.put(&quot;success&quot;,&quot;true&quot;); Object result = runner.execute(exp,context,null,false,true); System.out.println(result); System.out.println(context); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://bruce.bugmakers.club/categories/java/"}],"tags":[{"name":"awesome","slug":"awesome","permalink":"http://bruce.bugmakers.club/tags/awesome/"},{"name":"规则引擎","slug":"规则引擎","permalink":"http://bruce.bugmakers.club/tags/规则引擎/"}]},{"title":"vue | VUE组件 - 回到顶部","slug":"vue/vue组件 - 回到顶部","date":"2018-06-14T12:12:00.000Z","updated":"2019-01-08T15:07:02.751Z","comments":true,"path":"2018/06/14/vue/vue组件 - 回到顶部/","link":"","permalink":"http://bruce.bugmakers.club/2018/06/14/vue/vue组件 - 回到顶部/","excerpt":"","text":"组件效果图 组件使用示例 backTopDemo.vue1234567891011121314151617&lt;template&gt; &lt;div style=&quot;height: 2000px;&quot;&gt; &lt;back-top&gt;&lt;/back-top&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BackTop from &apos;../components/common/backTop&apos;export default &#123; name: &apos;backTopDemo&apos;, components: &#123;BackTop&#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 组件源码 backTop.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;transition name=&apos;slide-fade&apos;&gt; &lt;div class=&apos;page-component-up&apos; v-if=&apos;isShow&apos; @click=&apos;getTop&apos;&gt; &lt;i class=&quot;el-icon-caret-top&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;BackTop&apos;, data () &#123; return &#123; isShow: false &#125; &#125;, methods: &#123; // 添加样式，鼠标hover上去，改变颜色 addhoverClass (e) &#123; if (e.type === &apos;mouseover&apos; &amp;&amp; this.$el.classList) &#123; this.$el.classList.add(&apos;hover&apos;) &#125; else if (e.type === &apos;mouseout&apos; &amp;&amp; this.$el.classList) &#123; this.$el.classList.remove(&apos;hover&apos;) &#125; &#125;, showIcon () &#123; if (document.documentElement.scrollTop &gt; 100) &#123; this.isShow = true this.$el.addEventListener(&apos;mouseover&apos;, this.addhoverClass) this.$el.addEventListener(&apos;mouseout&apos;, this.addhoverClass) &#125; else if (document.documentElement.scrollTop &lt; 100) &#123; this.isShow = false &#125; &#125;, getTop () &#123; let timer = setInterval(() =&gt; &#123; let top = document.documentElement.scrollTop let speed = Math.ceil(top / 5) document.documentElement.scrollTop = top - speed if (top === 0) &#123; clearInterval(timer) &#125; &#125;, 20) &#125; &#125;, mounted () &#123; window.addEventListener(&apos;scroll&apos;, this.showIcon) &#125;, beforeDestroy () &#123; window.removeEventListener(&apos;scroll&apos;, this.showIcon) &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; rel=&quot;stylesheet/scss&quot;&gt;.slide-fade-enter-active &#123; transition: all .1s ease;&#125;.slide-fade-leave-active &#123; transition: all .1s cubic-bezier(1.0, 0.3, 0.8, 1.0); opacity: 0;&#125;.slide-fade-enter, .slide-fade-leave-to /* .slide-fade-leave-active 在低于 2.1.8 版本中 */ &#123; // transform: translateY(-20px); opacity: 0;&#125;.page-component-up &#123; background-color: #67C23A; position: fixed; right: 3rem; bottom: 8rem; width: 50px; height: 50px; border-radius: 25px; cursor: pointer; opacity: .3; transition: .3s; text-align: center; z-index: 999;&#125;.el-icon-caret-top &#123; font-size: 36px; margin-top: 7px; color: #FFFFFF; text-align: center; z-index: 1000&#125;.hover &#123; background-color: #409EFF;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://bruce.bugmakers.club/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/tags/前端/"}]},{"title":"vue | VUE - 教程收集","slug":"vue/vue基础","date":"2018-05-30T02:33:00.000Z","updated":"2019-01-08T15:07:02.766Z","comments":true,"path":"2018/05/30/vue/vue基础/","link":"","permalink":"http://bruce.bugmakers.club/2018/05/30/vue/vue基础/","excerpt":"","text":"主要内容整理自前端君的微信公众号：web前端教程，本文仅做个内容一览和跳转（跳转到原作者公众号文章） 最新更新：无论学习什么，多从官网渠道获取信息，vue中文官网：https://cn.vuejs.org/index.html VUE 基础：《vue2.0基础系列》目录大全 进阶：《vue2.0进阶系列》 ES 6前端君除了vue教程外，还做了es6的系列教程，vue是基于es开发的，所以学习es也是蛮有必要的，至于es是什么，自行学习哈 ES6：《ES6系列连载》 其他一个前端的在线文档：http://docs.720ui.com/api_docs_web.html","categories":[{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://bruce.bugmakers.club/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/tags/前端/"}]},{"title":"tools | 推荐一款本地文件检索工具：Launchy","slug":"tools/tools-launchy","date":"2018-04-25T14:10:00.000Z","updated":"2019-01-08T15:07:02.651Z","comments":true,"path":"2018/04/25/tools/tools-launchy/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/25/tools/tools-launchy/","excerpt":"","text":"1、演示 2、优点 轻量级，安装后占用空间才10+MB 操作简单，体验很好 免费 3、下载地址http://www.launchy.net/download.php#windows","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"tools | 推荐一款漂浮截图工具：SETUNA","slug":"tools/tools-setuna","date":"2018-04-23T05:10:00.000Z","updated":"2019-01-08T15:07:02.666Z","comments":true,"path":"2018/04/23/tools/tools-setuna/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/23/tools/tools-setuna/","excerpt":"","text":"1、演示 2、优点 轻量级，整个软件大小只有1.17MB 操作简单，体验很好 免费 3、下载地址 我的百度云 https://pan.baidu.com/s/1UKG2zZ0CYVOwBJQGy21C4w 类似小工具1）pureref，官网：https://www.pureref.com/ 推荐文章：https://cloud.tencent.com/developer/news/44018","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"tools | 推荐一款gif录制工具：LICEcap","slug":"tools/tools-liceecap","date":"2018-04-21T15:30:00.000Z","updated":"2019-01-08T15:07:02.738Z","comments":true,"path":"2018/04/21/tools/tools-liceecap/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/21/tools/tools-liceecap/","excerpt":"","text":"1、演示 2、优点 轻量级，整个软件大小只有1.17MB 操作简单，体验很好 免费 3、下载地址 官网 https://www.cockos.com/licecap/ 我的github仓库 https://github.com/BruceOuyang/issuelist/blob/master/tools/licecap126-install.zip 我的百度云 https://pan.baidu.com/s/13dNnFKf1ASq7ysMBjfcY4w","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"设计模式 | 开篇","slug":"design-pattern/00-boy-learning-design-pattern","date":"2018-04-19T23:13:00.000Z","updated":"2019-01-06T17:34:44.194Z","comments":true,"path":"2018/04/20/design-pattern/00-boy-learning-design-pattern/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/20/design-pattern/00-boy-learning-design-pattern/","excerpt":"","text":"Bruce Ouyang 正在学习《设计模式Java版》 http://woquanke.com/books/gof/这本书个人学习的主要内容以及对应源码记录在https://github.com/BruceOuyang/boy-design-pattern目录下 初衷 系统的学习一遍设计模式 书的原链接https://gof.quanke.name 这个地址貌似正常情况下访问不了，习惯了markdown不想去看csdn上旧风格的文章（quanke大神的csdn博客上也有一份设计模式）,故在此仓库copy一份，方便大家访问和一起学习 最新更新，原作者提供了新域名访问地址： http://woquanke.com/books/gof/ ，国内访问无压力 融入一点自己的风格：我将刘伟大神的设计模式一书内容分散在代码的各个包里边，方便阅读 原文中有一些练习，就在这个仓库的源码中做掉 二十四种设计模式一览 以下文章持续更新中… 创建型 六个创建型模式 SEQ1 - 简单工厂模式 Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 SEQ2 - 工厂方法模式 Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】 SEQ3 - 抽象工厂模式 Abstract Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】 SEQ4 - 单例模式 Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 SEQ5 - 原型模式 Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ6 - 建造者模式 Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】 结构型 七个结构型模式 SEQ1 - 适配器模式 Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】 SEQ2 - 桥接模式 Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ3 - 组合模式 Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 SEQ4 - 装饰模式 Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ5 - 外观模式 Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】 SEQ6 - 享元模式 Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 SEQ7 - 代理模式 Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 行为型 十一个行为型模式 SEQ01 - 职责链模式 Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 SEQ02 - 命令模式 Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 SEQ03 - 解释器模式 Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】 SEQ04 - 迭代器模式 Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 SEQ05 - 中介者模式 Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 SEQ06 - 备忘录模式 Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】 SEQ07 - 观察者模式 Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 SEQ08 - 状态模式 State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ09 - 策略模式 Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 SEQ10 - 模板方法模式 Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 SEQ11 - 访问者模式 Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 复习 设计模式趣味学习 设计模式于足球 设计模式综合应用实例 多人联机射击游戏 数据库同步服务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://bruce.bugmakers.club/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://bruce.bugmakers.club/tags/设计模式/"}]},{"title":"免费博客 | Hexo搭建博客并部署到Github Pages服务","slug":"hexo/hexo-githubpages-blog","date":"2018-04-19T14:05:00.000Z","updated":"2019-01-08T15:07:02.688Z","comments":true,"path":"2018/04/19/hexo/hexo-githubpages-blog/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/19/hexo/hexo-githubpages-blog/","excerpt":"","text":"本文实践的操作系统是windows 10，其他OS的可以当做参考用 一、Hexo搭建博客1. 环境准备 下载并安装 nodejs 下载并安装 git 直接上官网看指引即可，如有疑问可以在评论中留言说明 2. Hexo初始化博客 在命令行窗口中执行下列命令 使用npm安装hexo 1npm install -g hexo-cli 初始化你的博客项目 执行命令123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install &lt;folder&gt; 是你本地的文件目录，例如：F:\\bruce\\hexo\\bugmakerBlog，如果不写，则会在执行命令的当前目录初始化一个hexo博客项目 初始化的过程中会去github上下载一些东西，比如说默认的主题 landscape 之类的，需要等个几分钟 初始化完成后，你会得到一个这样的项目目录结构： _config.yml网站的主要配置文件，可以配置你网站的大部分信息。【配置参考说明】 简单的配置示例 key 说明 示例 title 网站的名字 BuG制造者联盟官方主页 author 网站的作者 Bruce language 语言设置 zh-CN package.json应用数据。 scaffolds目录模板目录，你新建一篇博客的时候会以这个目录中的模板文件来创建。 source目录资源目录，你新建的博客都存储在这里。在生成页面的时候，hexo会忽略掉命名为 _ 开头的文件或文件夹， _post 除外，会将 .md 和 .html 后缀的文件按主题生成页面，并复制到public目录下，其他后缀的文件则直接复制过去，不进行额外转换操作。 themes目录主题目录，你可以为自己的网站挑选好看的主题，然后在 _config.yml 文件中指定主题即可。 写一篇博客1hexo new [layout] &lt;title&gt; hexo new 会在 source目录 中创建一个以 &lt;title&gt; 命名的 .md 文件[layout] 是默认布局，在 scaffolds目录 下定义的，默认布局在 _config.yml 中指定，初始化的默认布局是 post&lt;title&gt; 是博客的标题，博客的标题可以在生成的 .md 文件中修改 示例1hexo new post My First Blog 生成页面并运行你的博客12hexo ghexo s -p 80 hexo g 是hexo生成页面指令 hexo generate 的缩写hexo s 是hexo启动本地服务的指令，默认端口是4000-p 80 是指定端口号80 默认访问地址 http://localhost:4000指定80端口访问地址 http://localhost 3. 切换博客主题在上一步中，我们看到的博客使用的主题是默认的 landscape 主题，hexo为我们提供了很多的主题可以选择，访问网站 https://hexo.io/themes/ 挑选自己喜欢的主题 将挑选好的主题 clone 到 theme目录 下，主题目录下也有一个 _config.yml 配置文件，这个配置文件即主题相关配置，具体根据主题的wiki上的说明来操作 在 _config.yml 中，设置 theme 属性的值为 theme目录 下的某一款主题即可，直接写目录下的文件夹名字 示例： clone主题到 theme目录 1git clone https://github.com/klugjo/hexo-theme-alpha-dust.git 修改根目录下的 _config.yml 配置文件，设置 theme 值 1theme : hexo-theme-alpha-dust 重新生成并启动本地服务 12hexo ghexo s -p 80 效果图 二、了解Github Pages服务GitHub Pages 网站：https://pages.github.com/ 1. 有什么用 Websites for you and your projects. 为你和你的项目提供一个网站Hosted directly from your GitHub repository. 直接托管存储在你的github仓库Just edit, push, and your changes are live. 只管去编辑提交代码到仓库，你的网站都会即时更新。 2. 怎么玩的 步骤其实很简单，在 Github Pages上都有如果你还没有github的账号，那需要先注册一个 第一步：在github上创建一个仓库，命名为 username.github.io username就是你的github用户名，注意不是登录账号，我仓库名字是 BuGMakerClub.github.io 第二步：将刚刚创建的仓库 clone 到本地，如 F:\\bruce\\bruce-private-github\\BuGMakerClub.github.io 12cd F:\\bruce\\bruce-private-github\\git clone https://github.com/BuGMakerClub/BuGMakerClub.github.io.git 第三步：在 clone 下来的项目中，创建一个 index.html，内容可以是 Hello World 12cd BuGMakerClub.github.ioecho &apos;Hello World&apos; &gt; index.html 第四步：提交代码，把刚创建的 index.html 文件 commit &amp; push 到你的 github仓库中 第五步：结束，你可以直接访问 https://username.github.io 访问你的网站了，我的网站地址是 https://BuGMakerClub.github.io 第六步：设置自己的个性化域名 如果你有自己的域名，可以在仓库的设置中绑定自己的个性化域名，然后在域名管理中心设置一个域名解析地址，这样就可以用个性化域名来访问github pages服务商的网页了 三、结合Hexo博客和Github Pages服务 参考：https://hexo.io/docs/deployment.html hexo的配置中，有一个 deploy 指令，可以将生成的博客网站部署到github仓库中，这样就形成两者的结合关系了。 具体操作如下 安装 hexo-deployer-git 插件1npm install hexo-deployer-git --save 修改根目录下的 _config.yml 配置文件 123deploy: type: git repo: https://github.com/BuGMakerClub/BuGMakerClub.github.io.git 执行 deploy 指令发布代码 1hexo d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/categories/hexo/"}],"tags":[{"name":"免费博客","slug":"免费博客","permalink":"http://bruce.bugmakers.club/tags/免费博客/"},{"name":"github pages","slug":"github-pages","permalink":"http://bruce.bugmakers.club/tags/github-pages/"}]},{"title":"免费博客 | Hello Hexo","slug":"hexo/hello-world","date":"2018-04-18T21:05:00.000Z","updated":"2019-01-08T15:07:02.709Z","comments":true,"path":"2018/04/19/hexo/hello-world/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/19/hexo/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/categories/hexo/"}],"tags":[{"name":"免费博客","slug":"免费博客","permalink":"http://bruce.bugmakers.club/tags/免费博客/"},{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/tags/hexo/"}]}]}