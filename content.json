{"meta":{"title":"BuGMaker' Bruce Ouyang","subtitle":null,"description":null,"author":"Bruce Ouyang","url":"http://bruce.bugmakers.club"},"pages":[{"title":"关于","date":"2018-04-19T06:13:36.000Z","updated":"2019-01-03T16:09:26.625Z","comments":true,"path":"about/index.html","permalink":"http://bruce.bugmakers.club/about/index.html","excerpt":"","text":"BuGMakersClub希望有想法的小伙伴们可以集结在一起，让所做的事情变得更有价值。 如果你对 BuGMakersClub 感兴趣，可以加我们的QQ群 111915819。 我我叫布鲁斯(Bruce)，一个简单的程序员。 Head Of BuGMakers"},{"title":"Categories","date":"2018-04-19T13:55:28.560Z","updated":"2018-04-17T23:19:52.693Z","comments":true,"path":"categories/index.html","permalink":"http://bruce.bugmakers.club/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-04-19T13:55:28.566Z","updated":"2018-04-17T23:19:52.693Z","comments":true,"path":"tags/index.html","permalink":"http://bruce.bugmakers.club/tags/index.html","excerpt":"","text":""},{"title":"我的简历| 2019版 | 欧阳强强 | 176-0212-5174 | Java高级工程师 | 7年工作经验","date":"2019-04-21T15:48:14.664Z","updated":"2019-04-21T15:48:14.658Z","comments":true,"path":"about/resume.html","permalink":"http://bruce.bugmakers.club/about/resume.html","excerpt":"","text":"联系方式 手机：17602125174 Email：oiiopro@live.cn QQ：1276541098 微信号：oiiopro 个人信息 欧阳强强(Bruce Ouyang) / 男 / 1992 专科 / 长沙学院 / 计算机应用技术 工作年限：7年 期望职位：Java高级程序员，架构师 期望薪资：面议 期望城市：上海 Github：http://github.com/bruceouyang 个人博客：http://bruceouyang.github.io 简书：https://www.jianshu.com/u/8bc5f4428ca2 CSDN：https://blog.csdn.net/boybruce 工作经历宝德融资租赁 （ 2018年5月 ~ 至今 ）工作时长：1年+离职原因： 德易车金融项目简述一个主打二手车交易市场的车金融平台级应用，从业务上分为几个模块：销售、风控、信审、金融产品、合同、撮配导标、财务和贷后，完整的业务流贯穿以上所有模块。 我以高级JAVA工程师身份加入团队，在项目初期在信审组做研发支持，后主要负责金融产品模块，角色是主开发（模块负责人）。 总结 做的比较出色：快速响应支持业务方的需求、老项目梳理以及新功能研发有较完备的文档输出、组员关系维护的良好工作热情高。 最困难的问题：在快速迭代的过程中对自己情绪的把控做的不是很好，跟产品经理之间会产生一些矛盾点。 当时解决方式：保持多沟通，给出建议产品经理和研发互相做一些妥协，确保新的业务功能如期上线。 其他总结：在工作表现上，领导给予较高的评价，例如做事情有条理、职业素养高、最大的优点是服务意识好。 掘新科技(上海)有限公司 （ 2015年8月 ~ 2018年4月 ）工作时长：2年8个月离职原因：不愿继续在外包公司工作 海银基金平台项目（互联网金融）简述一个与基金公司合作的基金中介平台。 个人作为高级JAVA工程师，加入团队，参与研发并负责一个6个人小团队的管理。 总结 做的比较出色：对系统分析文档整理的比较清晰，帮助同事熟悉业务和系统更顺利。 最困难的问题：刚上手的时候没有任何文档，给team成员带来了极大的困扰。 当时解决方式：我在熟悉项目的过程中，及时记录我看过的内容并整理成文档，然后分享给我的同事，并且把这个方法也推荐给他们。 其他总结：在项目过程中发现team管理不是很合理，跟领导沟通并推荐使用半敏捷的模式来做团队管理，得到了领导的认同。 博泰PAAS云平台项目（车联网）简述这是一个车联网项目，项目中包含的元素有很多，主要包含两个核心模块：云平台、车载终端设备。 在团队中，我的角色是JAVA工程师，主要负责支持云服务中的基础服务研发工作，如：ms_device/ms_ota 总结 做的比较出色：积极配合领导的工作，有问题及时沟通，能够按时按量的完成领导安排的工作。 最困难的问题：有很多没用过的新技术，如springboot、springcloud、zk、kafka。 当时解决方式：上官网找api文档学习、快速精准的阅读网上的博客，在github&amp;gitee上找相关源码学习。 其他总结：在这个项目中，我最自豪的是短时间内学习了很多新东西，还做了一回讲师，内部分享了《SpringCloud任务跟踪服务Sleuth组件》，在当年收到了公司发的教师节礼物。 德晟资本财富农场项目（互联网金融）简述这是一个P2P平台项目。 在团队中，我的角色是JAVA工程师，主要负责平台服务端的研发工作，也会参与一些营销活动的研发。 总结 做的比较出色：积极配合领导的工作，有问题及时沟通，能够按时按量的完成领导安排的工作。 最困难的问题：在做营销活动的时候，经常碰到刷活动的羊毛党，经常要与羊毛党斗智斗勇。 当时解决方式：后台做数据监控，封IP。 其他总结： 文聪信息科技有限公司 （ 2012年9月 ~ 2015年8月 ）工作时长：2年11个月离职原因：核心项目被收购 艾特网车载WiFi项目简述这是一个车辆网的项目。 在团队中，我的最终角色是公司的首席java工程师。 总结 做的比较出色：对业务了解的比较彻底，跟多个三方公司对接都比较顺利 最困难的问题：项目前期是外包的，接手回来之后接手项目比较困难 当时解决方式：积极与乙方同事沟通，关系处理恰当保障了沟通的顺利 其他总结：这个项目中，我最自豪的是，第一次去IDC机房装机，独自完成系统搭建和软件部署，第一次担任公司技术负责人，获得了公司首席java工程师的title、获得了年度优秀个人称号 MIS系统 做的比较出色的是：跟各部门负责人沟通需求很顺利、研发小组管理有条不紊 最困难的问题： 当时解决方式： 其他总结： 艾思特科技（上海）有限公司 （ 2011年11月 ~ 2012年9月 ）工作时长：10个月离职原因：专业不对口 TMS项目二次开发 做的比较出色的是：对业务的理解比较好，SQL写的还不错，用数据库存储过程实现了核心业务。 最困难的问题：当时被分配在的项目组做的是一个java swing方向的客户端应用，自己擅长的是java web应用研发，上手比较困难。 当时解决方式：硬着头皮上，逐步调试学习源码。 其他总结：当发现专业不对口时，应当及时提出，往自己擅长的方向靠拢。 技能清单 前端：html、jsp、css、js、jQuery、EasyUI、Vue等 后端：Servlet、Struts、Spring、SpringMVC、Hibernate、MyBatis、Netty等 数据库：MSSQL、Oracle、MySQL、MongoDB WEB服务器：Tomcat、Jetty、Websphere、Nginx 服务器操作系统：WindowServer、Linux（Redhat、Centos、Ubuntu） 分布式相关: SpringCloud、Dubbo、Zookeeper、Memcached、Redis、ActiveMQ、RabbitMQ、Kafka等 开发环境：jdk1.6、jdk1.7、jdk1.8 开发工具：Eclipse、MyEclipse、 Intellij IDEA 版本管理：Git、SVN 项目构建：Maven 文档：swagger、jdoc、oscteam 荣誉 2018年 获得公司《期权授予证书》 / 宝德融资租赁 2014年 获得公司《先进个人证书》 / 文聪科技 其他教育经历 长沙学院 (2014年2月 ~ 2016年6月) / 计算机应用技术专业 / 大专文凭 欧博泰克计算机学院 (2009年7月 ~ 2011年11月) / 计算机基础和软件开发 / 中级程序员证书 培训经历 网易微专业 / Java高级开发工程师 (2018年12月 ~ 2019年12月) / 进行中 上海市人力资源和社会保障局 (2014年9月 ~ 2015年3月) / JAVA（高级）培训 / 高级Java工程师证书 华尔街英语SH14 (2012年6月 ~ 2015年3月) / 英语口语培训课程 / 华尔街英语T1级别证书 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"}],"posts":[{"title":"Spring | Transaction 事物","slug":"spring/transaction/Spring 事物基础","date":"2019-04-21T15:57:00.000Z","updated":"2019-04-21T16:23:02.989Z","comments":true,"path":"2019/04/21/spring/transaction/Spring 事物基础/","link":"","permalink":"http://bruce.bugmakers.club/2019/04/21/spring/transaction/Spring 事物基础/","excerpt":"","text":"Spring 事物抽象 一致的事物模型 JDBC/Hibernate/MyBatis DataSource/JTA 事物抽象的核心接口PlatformTransactionManager DataSrouceTransactionManager HibernateTransactionManager JtaTransactionManager 123void commit(TransactionStatus status) throws TransactionException;void rollback(TransactionStatus status) throws TransactionException;TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; 事物传播特性// todo 事物隔离级别// todo","categories":[{"name":"spring","slug":"spring","permalink":"http://bruce.bugmakers.club/categories/spring/"}],"tags":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://bruce.bugmakers.club/tags/Java-基础/"},{"name":"Spring Transaction","slug":"Spring-Transaction","permalink":"http://bruce.bugmakers.club/tags/Spring-Transaction/"}]},{"title":"健康 | 为什么你总是感到疲劳？脑科学+冥想=最有效的休息方法","slug":"health/为什么你总是感到疲劳？脑科学+冥想=最有效的休息方法","date":"2019-01-26T15:05:00.000Z","updated":"2019-01-26T16:05:42.723Z","comments":true,"path":"2019/01/26/health/为什么你总是感到疲劳？脑科学+冥想=最有效的休息方法/","link":"","permalink":"http://bruce.bugmakers.club/2019/01/26/health/为什么你总是感到疲劳？脑科学+冥想=最有效的休息方法/","excerpt":"","text":"利用脑科学和冥想来解决疲劳问题的七种方法前言大多数人认为：只要什么都不干，大脑就可以好好休息了。 真实情况是：即使你什么都不做，大脑还是会疲惫。 原因：大脑虽然最多占人体重量的2%，但却消耗了全部能量的20%，是名副其实的“大胃王”。而且，其中，大脑所消耗能量的60%至80%被DMN（即default mode network）消耗掉了。DMN是一种无意识的活动，始终处于自动进行的状态。 那么真正的休息是什么 真正的休息并非是“单向性地充电”，而是利用大脑的可塑性，改变大脑的样态，使之变成正念，不容易疲劳的大脑。 1、无论什么时候大脑感到疲惫，都可以使用正念呼吸法重点：容易疲劳的大脑是因为不懂活在“现在”。 解释：注意力散漫、无气力、烦躁不安等现象都是大脑疲劳的表现。这些现象的根本原因是，人的意识总是在考虑过去或者未来，是没有”就在当下”的状态，慢性恶化的结果。通过“心的练习”，使意识面对现在，就可以锻炼出不容易疲劳的大脑。 效果目标：减轻压力、减少杂念、提高注意力和记忆力、更好控制感情、改善免疫机能。 步骤： 1.1、做好基本姿势坐在椅子上（轻展后背肌肉、后背不要离开椅子） 腹部放松，手放在大腿上，脚不要交叉 闭上眼睛（睁开眼睛也行，看着2米外的前方） 1.2、把意识向身体的感觉集中接触的感觉（脚底和地板、臀部和椅子、双手和大腿） 身体感觉地球吸引的重力 1.3、注意呼吸将意识向与呼吸有关的感觉集中（感受空气通过鼻腔/空气呼入吐出时胸和腹部的上下起伏/各式各样呼吸的深度/吸气与吐气的温度差，等等） 不要深呼吸或者控制呼吸（自然地呼吸即可，像”等待”一样） 给呼吸标记上1、2……10等数字效果会更好 1.4、如果浮现杂念的话…发现有杂念浮现的话，讲注意力拉回到呼吸上（呼吸是“意识的锚”） 要点：每天5分钟也行、10分钟也行，关键是每天都要坚持； 在同样的时间、同样的场所进行（大脑喜欢“习惯”） 2、关注事情和思考问题的时候，可以使用行为冥想重点：摆脱让大脑疲劳的“自动操纵状态” 解释：现代社会是多项任务同时进行的时代。谁都是“在干着一件事的过程中”又干着另外一件事。日常行为中，在“自动操纵状态”下，大脑中特别容易浮现杂念。如果这种状态经常发生，那么注意力、集中力底下也不足为奇了。GOOGLE公司的职员都进行一种名为【S－Y】的动作冥想锻炼，我们也来试一试。 目标效果：改善注意力和集中力、实现心流的状态。 步骤： 2.1、步行冥想 速度自由决定， 但推荐最开始慢行 注意体会手脚肌肉和关节的活动、与地面接触的感觉 【右/左】或者【上/下】，自己的行动方向标记出来 2.2、站立姿势的动作冥想 双脚与肩同宽站立，两手分别向左向右伸直，然后缓慢向上抬 注意感觉手腕肌肉的运动、血液向下流动，把意识引向重力 手抬上来之后，再缓慢的放下，如此重复 2.3、坐下姿势的动作冥想保持坐在椅子上的状态，从后向前缓慢绕动双肩 细心地注意肌肉和关节的动作和感觉 绕完一圈，逆向再把肩绕回来，同样注意动作和感觉 2.4、其他的各种方法注意把意识集中到日常的活动（穿衣服/刷牙等等） 开车的过程中，注意坐垫和臀部的接触感、手在方向盘上的感觉、踩踏刹车时肌肉和关节运动的感觉 边做广播体操边注意身体的运动和感觉 要点【出门就开始】【出了地铁检票口就开始】等等，决定动作冥想的时间要很明确地决定，这样容易养成习惯 每日用餐的时候都注意 3、防止被压力摧毁健康，使用BREATHING SPACE重点：大脑的构造发生变化，产生压力的方式也会变化。 解释虽然压力是大脑内部的现象，慢性压力对身体会产生各种各样的影响。慢慢地身体会出现倦怠或者肩痛等症状、突发的腹痛、胃肠炎等。研究发现到了压力对身体的影响，从大脑（前头叶和扁桃体的关系）开始改善的方法也有了。 目标效果缓解压力以及压力带来的紧张感，改善其他不良反应。 步骤： 3.1、意识到压力的影响调整到精神性冥想的基本姿势 用”一句话”分析说明形成压力的原因 在心中默答这句话，确认心里和身体的反应 3.2、集中注意到呼吸上用1、2等标注呼吸 感受身体的紧张感逐步放松 3.3、把意识扩展到全身把注意力向全身扩展（想象身体全体在呼吸） 吸气的时候，把空气送到对压力起反应的身体部位 进一步，把注意力向周围空间扩展。 要点：也包括身体的疲劳，主要原因是大脑通过讲压力的原因语言化，能够客观看待自己的【认知错误】 4、想要脱离思考的怪圈的时候，使用猴杂心理解除法重点：让大脑中反复出现的【思考的猴子】闭嘴 解释：脑袋中各种各样的杂念像漩涡一样的状态，也叫猴杂心理，使大脑的能量巨大浪费，不断地积攒疲劳，还让睡眠质量底下。遇到这样的情况，首先要改变与杂念相对应的“认知”。对反复出现的思考起个”名字”，可以不那么容易陷入思考循环中。 目标效果：抑制思考循环、提高集中力、避免自我讨厌、改善睡眠、深度睡眠。方法： 4.1、舍弃给思想贴上标签，是自己注意到“已经思考过很多次了”向大脑外部发出”够了！”的信息 4.2、考虑例外情况出现了同样的思考方式，是不是因为设定了同样的前提？尝试考虑这样思考不正确的例子 4.3、想想贤者的眼光如果是自己尊敬的人或者历史上的伟人，（对这个问题）如何思考？是不是把【各种杂念的东西】与【抱有杂念的自己】看成一回事了？ 4.4、不要去判断善恶好坏是不是用了【现在当下】以外的标准去评价事物？注意”不要下判断”(no judgement) 4.5、探索缘由这种想法数次出现的原因是什么？从自己的“深层愿望”出发改变思考方法 要点：【杂念=电车】【自己=站台】这样的认知行动疗法是有效的思考的循环会妨碍睡眠（大脑的洗净） 5、快要被怒气或冲动左右时，使用RAIN重点：制造出一个不会陷入【扁桃体劫持】的大脑 解释：大脑在压力过度的情况下，控制本能和情感的扁桃体就会暴走。通常情况下，负责理性的前头叶会将扁桃体抑制住，而且持续冥想的话，可以制造出两者处于平衡状态的大脑构造。感到愤怒的时候，RAIN是控制冲动的四个步骤。 步骤： 5.1、RECOGNIZE（认识）认识到自己心中怒火燃起的原因 不要把怒气和生气的自己视为一回事 5.2、ACCEPT（接受）接受让你生气的那件事实 对这件事不要进行价值评价，就这样允许它存在 5.3、INVESTIGATE（检证）检查一下生气时候的身体起了那些反应 心跳如何变化 身体的何处紧张 5.4、NON－IDENTIFICATION（保持距离）不要把自己的感情认为是自己的问题 把怒气分离开来，好像是别人的事情那样去思考 要点：对怒气以外的各种各样的冲动都有效目的意识高的人，内心不容易放松，很容易冲动。 6、对他人有负面情绪时，使用“温柔的慈悲”重点：为了消解大脑的疲劳，要培养【向前看的情感】 解释：不管是谁，都有“怎么都无法喜欢的人”。实际上，压力大部分来源于人际关系。通过减少对他人的讨厌、嫉妒、生气等负面情感，培育对他人的爱情、慈悲，制造出一个很难积累疲惫的大脑。 目标效果：抑制对他人的负面情感、培养对积极的感情。 步骤： 6.1、保持精神性的意识状态连续10分钟保持通常的精神性敏想 从负面的感情向【现在当下】改变 6.2、浮现关于这个人的想法想象那个造成压力的人 注意留心身心变化 6.3、在心中唱祝福语【愿你在各种各样的危险中获得安全】【愿你幸福心安】【愿你健康】 要点：UCLA也导入了慈悲计划慈悲可以抑制大脑疲劳的原因（DMN的活动过剩） 7、身体不舒服、疼痛的时候，身体检视（BODYSCAN）重点：把身体的疲惫和痛苦从大脑中解放出来。 解释：大脑的状态，通过自律神经或荷尔蒙在身体上反映出来。大脑的疲劳积累严重的话，身体的一部分会产生灼烧感和疲劳感，严重的情况下，会发生局部性疼痛。精神性冥想，不仅对短期的疼痛有抑制作用，而且在创造能应对疼痛的大脑构造上也有效果。 目的效果：压力性的疼痛、皮肤疾患、调整自律神经。 步骤： 7.1、横躺，注意呼吸坐在椅子上也可以 随着呼吸注意感觉腹部上下活动 7.2、先注意感受左脚的末端脚在鞋子或袜子的感觉怎么样 脚趾头和相邻指头接触的感觉怎么样 7.3、扫描身体下半身先从左脚的末端开始【扫描】 呼气时：气息从鼻子进入，通过身体先流向左脚末端 呼气时：在左脚末端的空气，通过身体由鼻子呼出 7.4、同样的过程应用到全身从左脚开始到左腿的扫描结束后，同样扫描右脚、左右的手、头以及腹部等地方 观察疼痛的地方（注意疼痛强度和性质的”波动”），同样地进行扫描 要点：对肩痛以及全身的疲乏都有效果注意“身体的感觉在如何变化”。 关于作者和书的简介：书名：世界のエリートがやっている最高の休息法—「脳科学 瞑想」で集中力が高まる 转自：简书文章：知力计划|为什么你总是感到疲劳？脑科学+冥想=最有效的休息方法","categories":[{"name":"健康","slug":"健康","permalink":"http://bruce.bugmakers.club/categories/健康/"}],"tags":[{"name":"健康","slug":"健康","permalink":"http://bruce.bugmakers.club/tags/健康/"},{"name":"大脑","slug":"大脑","permalink":"http://bruce.bugmakers.club/tags/大脑/"},{"name":"冥想","slug":"冥想","permalink":"http://bruce.bugmakers.club/tags/冥想/"}]},{"title":"开发工具 | Intellij IDEA神器居然还有这些小技巧","slug":"idea/Intellij IDEA神器居然还有这些小技巧","date":"2019-01-11T05:17:57.446Z","updated":"2019-01-11T05:17:57.447Z","comments":true,"path":"2019/01/11/idea/Intellij IDEA神器居然还有这些小技巧/","link":"","permalink":"http://bruce.bugmakers.club/2019/01/11/idea/Intellij IDEA神器居然还有这些小技巧/","excerpt":"","text":"","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://bruce.bugmakers.club/categories/开发工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://bruce.bugmakers.club/tags/idea/"}]},{"title":"JAVA基础 | JAVA程序运行原理分析","slug":"java/base/JAVA程序运行原理分析","date":"2019-01-07T16:00:00.000Z","updated":"2019-01-08T17:55:33.205Z","comments":true,"path":"2019/01/08/java/base/JAVA程序运行原理分析/","link":"","permalink":"http://bruce.bugmakers.club/2019/01/08/java/base/JAVA程序运行原理分析/","excerpt":"","text":"Java程序的运行，首先会将源码文件(.java)编译成Class文件(.class)，进而jvm会去解析class文件，将其解释为操作系统可识别的指令进行运算。 JVM 运行时数据区 线程独占：每个线程都会有它独立的空间，随线程生命周期而创建和销毁 线程共享：所有线程能访问这块内存数据，随虚拟机或者GC而创建和销毁 方法区 方法区，JVM用来存储加载的：类、常量、静态变量、编译后的代码等数据。 虚拟机规范中这是一个逻辑划分区，具体实现根据不同虚拟机来实现。 如：oracle的HotSpot在java7中方法区放在永久代，java8放在元数据空间，并且通过GC机制对这个区域进行管理 堆内存 堆内存，还可以细分为：老年代、新生代(Eden、From Survivor、To Survivor)。 JVM启动是创建，存放对象的实例。垃圾回收器主要就是管理堆内存。 如果满了，就会出现OutOfMemoryError。 虚拟机栈 虚拟机栈，是为虚拟机执行JAVA方法而准备的。 每个线程在这个空间有一个私有空间，线程栈由多个栈帧(Stack Frame)组成。 一个线程会执行一个或多个方法，一个方法对应一个栈帧。 栈帧内容包含：局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。 栈内存默认最大是1MB，超出则抛出StackOverflowError。 本地方法栈 本地方法栈，是为虚拟机使用Native本地方法而准备的。 虚拟机规范没有规定具体的实现，由不同的虚拟机厂商去实现。 HotSpot虚拟机中虚拟机栈和本地方法栈的实现是一样的。同样，超出大小则抛出StackOverflowError。 程序计数器 程序计数器(Program Counter Register)，记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行Native方法，则计数器值为空。 每个线程都在这个空间有一个私有空间，占用内存空间很少。 CPU同一时间，只会执行一条线程中的指令。JVM多线程会轮流切换并分配CPU执行时间的方式。为了线程切换后，需要通过程序计数器来恢复正确的执行位置。 class 文件内容class文件包含JAVA程序执行的字节码；数据严格按照格式紧凑排列在class文件中的二进制流，中间无任何分隔符；文件开头有一个0xcafebabe(16进制)特殊的一个标志。 查看class文件内容准备一个java文件，例如：123456789public class Demo1 &#123; public static void main(String[] args) &#123; int x = 500; int y = 100; int a = x / y; int b = 50; System.out.println(a + b); &#125;&#125; 使用命令 javac 来编译一个 .java 文件，编译成功之后会生成一个 .class 文件，例如：1javac Demo1.java 使用命令 javap 来解析一个 .class 文件，会输出解析结果，我们可以将解析结果保存在一个 .txt 文件中，例如：1javap -v Demo1.class&gt;Demo1.txt class内容 - 版本号/访问标识javap输出内容摘要：12345public class club.bugmakers.boyneteasejava.demo.Demo1 minor version: 0 //次版本号 major version: 52 //主版本号 flags: ACC_PUBLIC, ACC_SUPER //访问标志 ... 版本号规则：JDK5,6,7,8分别对应49,50,51,52 访问标志： class内容 - 常量池javap输出内容摘要：123456789101112131415161718192021222324252627Constant pool: #1 = Methodref #5.#14 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #15.#16 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #17.#18 // java/io/PrintStream.println:(I)V #4 = Class #19 // club/bugmakers/boyneteasejava/demo/Demo1 #5 = Class #20 // java/lang/Object #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 main #11 = Utf8 ([Ljava/lang/String;)V #12 = Utf8 SourceFile #13 = Utf8 Demo1.java #14 = NameAndType #6:#7 // &quot;&lt;init&gt;&quot;:()V #15 = Class #21 // java/lang/System #16 = NameAndType #22:#23 // out:Ljava/io/PrintStream; #17 = Class #24 // java/io/PrintStream #18 = NameAndType #25:#26 // println:(I)V #19 = Utf8 club/bugmakers/boyneteasejava/demo/Demo1 #20 = Utf8 java/lang/Object #21 = Utf8 java/lang/System #22 = Utf8 out #23 = Utf8 Ljava/io/PrintStream; #24 = Utf8 java/io/PrintStream #25 = Utf8 println #26 = Utf8 (I)V 类信息包含的静态常量，编译之后就能确认，比如：类的名称、方法名称。 常量池常见类型： class内容 - 构造方法javap输出内容摘要：12345678910public club.bugmakers.boyneteasejava.demo.Demo1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 10: 0 Demo1这个示例中，我们并没有写构造函数。 由此可见，没有定义构造函数时，会有隐式的无参构造函数。 class内容 - 程序入口main方法 JVM指令码表 程序完整运行分析加载信息到方法区 JVM创建线程来执行代码 线程独占空间和执行指令码 …依次执行，直到最后一个字节码指令执行完成 总结本文对JVM运行的核心逻辑进行了详细剖析。 注意： JVM运行原理中更底层实现，针对不同的操作系统或者处理器，会有不同的实现。 这也是JAVA能够实现“一处编写，到处运行”的原因。 开发人员理解到这个层次，就足够学习掌握多线程的相关知识了。","categories":[{"name":"java","slug":"java","permalink":"http://bruce.bugmakers.club/categories/java/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"http://bruce.bugmakers.club/tags/JAVA基础/"},{"name":"JAVA高性能编程","slug":"JAVA高性能编程","permalink":"http://bruce.bugmakers.club/tags/JAVA高性能编程/"},{"name":"运行原理","slug":"运行原理","permalink":"http://bruce.bugmakers.club/tags/运行原理/"},{"name":"网易微专业","slug":"网易微专业","permalink":"http://bruce.bugmakers.club/tags/网易微专业/"}]},{"title":"awesome | 规则引擎 - QLExpress","slug":"awesome/QLExpress","date":"2018-12-22T09:03:00.000Z","updated":"2019-01-08T15:07:02.636Z","comments":true,"path":"2018/12/22/awesome/QLExpress/","link":"","permalink":"http://bruce.bugmakers.club/2018/12/22/awesome/QLExpress/","excerpt":"","text":"一、简介QlExpress脚本语言解析工具诞生于2010年，是玄难大师根据当时汇金的业务需要开始编写。 该项目是由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。 QlExpress经过40多个小版本的迭代，性能和功能更加趋于稳定，被更多的团队接受和认可，在双11洪流高峰、复杂规则业务配置平台等场景下也得到更好的实战考验。 开源地址：https://github.com/alibaba/QLExpress 二、使用1、 依赖和调用说明maven 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;QLExpress&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 简单示例12345678ExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();context.put(&quot;a&quot;,1);context.put(&quot;b&quot;,2);context.put(&quot;c&quot;,3);String express = &quot;a+b*c&quot;;Object r = runner.execute(express, context, null, true, false);System.out.println(r); 2、语法介绍2.1 操作符和 java 对象操作普通 Java 语法12345678910111213//支持 +,-,*,/,&lt;,&gt;,&lt;=,&gt;=,==,!=,&lt;&gt;【等同于!=】,%,mod【取模等同于%】,++,--,//in【类似sql】,like【sql语法】,&amp;&amp;,||,!,等操作符//支持for，break、continue、if then else 等标准的程序控制逻辑n=10;for(sum=0,i=0;i&lt;n;i++)&#123;sum=sum+i;&#125;return sum; //逻辑三元操作a=1;b=2;max = a&gt;b?a:b; Java 的对象操作12345678import com.ql.util.express.test.OrderQuery;//系统自动会import java.lang.*,import java.util.*;query = new OrderQuery();//创建class实例,会根据classLoader信息，自动补全类路径query.setCreateDate(new Date());//设置属性query.buyer = &quot;张三&quot;;//调用属性,默认会转化为setBuyer(&quot;张三&quot;)result = bizOrderDAO.query(query);//调用bean对象的方法System.out.println(result.getId());//静态方法 2.2 脚本中定义function12345678910function add(int a,int b)&#123; return a+b;&#125;;function sub(int a,int b)&#123; return a - b;&#125;;a=10;return add(a,4) + sub(a,9); 2.3 扩展操作符：Operator替换if then else 等关键字1234567runner.addOperatorWithAlias(&quot;如果&quot;, &quot;if&quot;,null);runner.addOperatorWithAlias(&quot;则&quot;, &quot;then&quot;,null);runner.addOperatorWithAlias(&quot;否则&quot;, &quot;else&quot;,null);exp = &quot;如果 (语文+数学+英语&gt;270) 则 &#123;return 1;&#125; 否则 &#123;return 0;&#125;&quot;;DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.execute(exp,context,null,false,false,null); 如何自定义Operator12345678910111213141516//定义一个继承自com.ql.util.express.Operator的操作符public class JoinOperator extends Operator&#123; public Object executeInner(Object[] list) throws Exception &#123; Object opdata1 = list[0]; Object opdata2 = list[1]; if(opdata1 instanceof java.util.List)&#123; ((java.util.List)opdata1).add(opdata2); return opdata1; &#125;else&#123; java.util.List result = new java.util.ArrayList(); result.add(opdata1); result.add(opdata2); return result; &#125; &#125;&#125; 如何使用Operator1234567891011121314151617181920212223//(1)addOperatorExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.addOperator(&quot;join&quot;,new JoinOperator());Object r = runner.execute(&quot;1 join 2 join 3&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3]//(2)replaceOperatorExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.replaceOperator(&quot;+&quot;,new JoinOperator());Object r = runner.execute(&quot;1 + 2 + 3&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3]//(3)addFunctionExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.addFunction(&quot;join&quot;,new JoinOperator());Object r = runner.execute(&quot;join(1,2,3)&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3] 2.4 绑定java类或者对象的methodaddFunctionOfClassMethod + addFunctionOfServiceMethod123456789101112131415161718192021222324252627public class BeanExample &#123; public static String upper(String abc) &#123; return abc.toUpperCase(); &#125; public boolean anyContains(String str, String searchStr) &#123; char[] s = str.toCharArray(); for (char c : s) &#123; if (searchStr.contains(c+&quot;&quot;)) &#123; return true; &#125; &#125; return false; &#125;&#125;runner.addFunctionOfClassMethod(&quot;取绝对值&quot;, Math.class.getName(), &quot;abs&quot;, new String[] &#123; &quot;double&quot; &#125;, null);runner.addFunctionOfClassMethod(&quot;转换为大写&quot;, BeanExample.class.getName(), &quot;upper&quot;, new String[] &#123; &quot;String&quot; &#125;, null);runner.addFunctionOfServiceMethod(&quot;打印&quot;, System.out, &quot;println&quot;,new String[] &#123; &quot;String&quot; &#125;, null);runner.addFunctionOfServiceMethod(&quot;contains&quot;, new BeanExample(), &quot;anyContains&quot;, new Class[] &#123; String.class, String.class &#125;, null);String exp = “取绝对值(-100);转换为大写(\\&quot;hello world\\&quot;);打印(\\&quot;你好吗？\\&quot;);contains(&quot;helloworld&quot;,\\&quot;aeiou\\&quot;)”;runner.execute(exp, context, null, false, false); 2.5 macro 宏定义123456789runner.addMacro(&quot;计算平均成绩&quot;, &quot;(语文+数学+英语)/3.0&quot;);runner.addMacro(&quot;是否优秀&quot;, &quot;计算平均成绩&gt;90&quot;);IExpressContext&lt;String, Object&gt; context =new DefaultContext&lt;String, Object&gt;();context.put(&quot;语文&quot;, 88);context.put(&quot;数学&quot;, 99);context.put(&quot;英语&quot;, 95);Object result = runner.execute(&quot;是否优秀&quot;, context, null, false, false);System.out.println(r);//返回结果true 2.6 编译脚本，查询外部需要定义的变量和函数 注意以下脚本int和没有int的区别12345678910111213String express = &quot;int 平均分 = (语文+数学+英语+综合考试.科目2)/4.0;return 平均分&quot;;ExpressRunner runner = new ExpressRunner(true,true);String[] names = runner.getOutVarNames(express);for(String s:names)&#123; System.out.println(&quot;var : &quot; + s);&#125;//输出结果：var : 数学var : 综合考试var : 英语var : 语文 2.7 关于不定参数的使用12345678910111213141516171819202122@Test public void testMethodReplace() throws Exception &#123; ExpressRunner runner = new ExpressRunner(); IExpressContext&lt;String,Object&gt; expressContext = new DefaultContext&lt;String,Object&gt;(); runner.addFunctionOfServiceMethod(&quot;getTemplate&quot;, this, &quot;getTemplate&quot;, new Class[]&#123;Object[].class&#125;, null); //(1)默认的不定参数可以使用数组来代替 Object r = runner.execute(&quot;getTemplate([11,&apos;22&apos;,33L,true])&quot;, expressContext, null,false, false); System.out.println(r); //(2)像java一样,支持函数动态参数调用,需要打开以下全局开关,否则以下调用会失败 DynamicParamsUtil.supportDynamicParams = true; r = runner.execute(&quot;getTemplate(11,&apos;22&apos;,33L,true)&quot;, expressContext, null,false, false); System.out.println(r); &#125; //等价于getTemplate(Object[] params) public Object getTemplate(Object... params) throws Exception&#123; String result = &quot;&quot;; for(Object obj:params)&#123; result = result+obj+&quot;,&quot;; &#125; return result; &#125; 2.8 关于集合的快捷写法1234567891011121314@Testpublic void testSet() throws Exception &#123; ExpressRunner runner = new ExpressRunner(false,false); DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;(); String express = &quot;abc = NewMap(1:1,2:2); return abc.get(1) + abc.get(2);&quot;; Object r = runner.execute(express, context, null, false, false); System.out.println(r); express = &quot;abc = NewList(1,2,3); return abc.get(1)+abc.get(2)&quot;; r = runner.execute(express, context, null, false, false); System.out.println(r); express = &quot;abc = [1,2,3]; return abc[1]+abc[2];&quot;; r = runner.execute(express, context, null, false, false); System.out.println(r);&#125; 2.9 集合的遍历其实类似java的语法，只是ql不支持for(obj:list){}的语法，只能通过下标访问12345678910//遍历map map = new HashMap(); map.put(&quot;a&quot;, &quot;a_value&quot;); map.put(&quot;b&quot;, &quot;b_value&quot;); keySet = map.keySet(); objArr = keySet.toArray(); for (i=0;i&lt;objArr.length;i++) &#123; key = objArr[i]; System.out.println(map.get(key)); &#125; 3、运行参数和API列表介绍QLExpressRunner如下图所示，从语法树分析、上下文、执行过程三个方面提供二次定制的功能扩展。 3.1 属性开关isPrecise1234/** * 是否需要高精度计算 */private boolean isPrecise = false; 高精度计算在会计财务中非常重要，java的float、double、int、long存在很多隐式转换，做四则运算和比较的时候其实存在非常多的安全隐患。 所以类似汇金的系统中，会有很多BigDecimal转换代码。而使用QLExpress，你只要关注数学公式本身 订单总价 = 单价 数量 + 首重价格 + （ 总重量 - 首重） 续重单价 ，然后设置这个属性即可，所有的中间运算过程都会保证不丢失精度。 isShortCircuit1234/** * 是否使用逻辑短路特性 */private boolean isShortCircuit = true; 在很多业务决策系统中，往往需要对布尔条件表达式进行分析输出，普通的java运算一般会通过逻辑短路来减少性能的消耗。例如规则公式： star&gt;10000 and shoptype in(‘tmall’,’juhuasuan’) and price between (100,900) 假设第一个条件 star&gt;10000 不满足就停止运算。但业务系统却还是希望把后面的逻辑都能够运算一遍，并且输出中间过程，保证更快更好的做出决策。 参照单元测试: ShortCircuitLogicTest.java isTrace1234/** * 是否输出所有的跟踪信息，同时还需要log级别是DEBUG级别 */private boolean isTrace = false; 这个主要是是否输出脚本的编译解析过程，一般对于业务系统来说关闭之后会提高性能。 3.2 调用入参123456789101112/** * 执行一段文本 * @param expressString 程序文本 * @param context 执行上下文，可以扩展为包含ApplicationContext * @param errorList 输出的错误信息List * @param isCache 是否使用Cache中的指令集,建议为true * @param isTrace 是否输出详细的执行指令信息，建议为false * @param aLog 输出的log * @return * @throws Exception */Object execute(String expressString, IExpressContext&lt;String,Object&gt; context,List&lt;String&gt; errorList, boolean isCache, boolean isTrace, Log aLog); 3.3 功能扩展API列表QLExpress主要通过子类实现Operator.java提供的以下方法来最简单的操作符定义，然后可以被通过addFunction或者addOperator的方式注入到ExpressRunner中。1public abstract Object executeInner(Object[] list) throws Exception; 比如我们几行代码就可以实现一个功能超级强大、非常好用的join操作符:list = 1 join 2 join 3; -&gt; [1,2,3] list = join(list,4,5,6); -&gt; [1,2,3,4,5,6]123456789101112131415public class JoinOperator extends Operator&#123; public Object executeInner(Object[] list) throws Exception &#123; java.util.List result = new java.util.ArrayList(); Object opdata1 = list[0]; if(opdata1 instanceof java.util.List)&#123; result.addAll((java.util.List)opdata1); &#125;else&#123; result.add(opdata1); &#125; for(int i=1;i&lt;list.length;i++)&#123; result.add(list[i]); &#125; return result; &#125;&#125; 如果你使用Operator的基类OperatorBase.java将获得更强大的能力，基本能够满足所有的要求。 3.3.1 function相关API12345678910111213141516//通过name获取function的定义OperatorBase getFunciton(String name);//通过自定义的Operator来实现类似：fun(a,b,c)void addFunction(String name, OperatorBase op);//fun(a,b,c) 绑定 object.function(a,b,c)对象方法void addFunctionOfServiceMethod(String name, Object aServiceObject, String aFunctionName, Class&lt;?&gt;[] aParameterClassTypes, String errorInfo);//fun(a,b,c) 绑定 Class.function(a,b,c)类方法void addFunctionOfClassMethod(String name, String aClassName, String aFunctionName, Class&lt;?&gt;[] aParameterClassTypes, String errorInfo);//给Class增加或者替换method，同时 支持a.fun(b) ，fun(a,b) 两种方法调用//比如扩展String.class的isBlank方法:“abc”.isBlank()和isBlank(&quot;abc&quot;)都可以调用void addFunctionAndClassMethod(String name,Class&lt;?&gt;bindingClass, OperatorBase op); 3.3.2 Operator相关API提到脚本语言的操作符，优先级、运算的目数、覆盖原始的操作符(+,-,*,/等等)都是需要考虑的问题，QLExpress统统帮你搞定了。123456789//添加操作符号,可以设置优先级void addOperator(String name,Operator op);void addOperator(String name,String aRefOpername,Operator op); //替换操作符处理OperatorBase replaceOperator(String name,OperatorBase op); //添加操作符和关键字的别名，比如 if..then..else -&gt; 如果。。那么。。否则。。void addOperatorWithAlias(String keyWordName, String realKeyWordName, String errorInfo); 3.3.3 宏定义相关APIQLExpress的宏定义比较简单，就是简单的用一个变量替换一段文本，和传统的函数替换有所区别。12//比如addMacro(&quot;天猫卖家&quot;,&quot;userDO.userTag &amp;1024 ==1024&quot;)void addMacro(String macroName,String express) 3.3.4 java class的相关apiQLExpress可以通过给java类增加或者改写一些method和field，比如 链式调用：”list.join(“1”).join(“2”)”，比如中文属性：”list.长度”。12345//添加类的属性字段void addClassField(String field,Class&lt;?&gt;bindingClass,Class&lt;?&gt;returnType,Operator op);//添加类的方法void addClassMethod(String name,Class&lt;?&gt;bindingClass,OperatorBase op); 注意，这些类的字段和方法是执行器通过解析语法执行的，而不是通过字节码增强等技术，所以只在脚本运行期间生效，不会对jvm整体的运行产生任何影响，所以是绝对安全的。 3.3.5 语法树解析变量、函数的API这些接口主要是对一个脚本内容的静态分析，可以作为上下文创建的依据，也可以用于系统的业务处理。比如：计算 “a+fun1(a)+fun2(a+b)+c.getName()” 包含的变量:a,b,c 包含的函数:fun1,fun21234//获取一个表达式需要的外部变量名称列表String[] getOutVarNames(String express);String[] getOutFunctionNames(String express); 3.3.6 语法解析校验api脚本语法是否正确，可以通过ExpressRunner编译指令集的接口来完成。123String expressString = &quot;for(i=0;i&lt;10;i++)&#123;sum=i+1&#125;return sum;&quot;;InstructionSet instructionSet = expressRunner.parseInstructionSet(expressString);//如果调用过程不出现异常，指令集instructionSet就是可以被加载运行（execute）了！ 3.3.7 指令集缓存相关的api因为QLExpress对文本到指令集做了一个本地HashMap缓存，通常情况下一个设计合理的应用脚本数量应该是有限的，缓存是安全稳定的，但是也提供了一些接口进行管理。1234//优先从本地指令集缓存获取指令集，没有的话生成并且缓存在本地InstructionSet getInstructionSetFromLocalCache(String expressString);//清除缓存void clearExpressCache(); 3.3.8 增强上下文参数Context相关的api - 01与spring框架的无缝集成上下文参数 IExpressContext context 非常有用，它允许put任何变量，然后在脚本中识别出来。在实际中我们很希望能够无缝的集成到spring框架中，可以仿照下面的例子使用一个子类。1234567891011121314151617181920212223242526272829303132333435public class QLExpressContext extends HashMap&lt;String, Object&gt; implements IExpressContext&lt;String, Object&gt; &#123; private ApplicationContext context; //构造函数，传入context和 ApplicationContext public QLExpressContext(Map&lt;String, Object&gt; map, ApplicationContext aContext) &#123; super(map); this.context = aContext; &#125; /** * 抽象方法：根据名称从属性列表中提取属性值 */ public Object get(Object name) &#123; Object result = null; result = super.get(name); try &#123; if (result == null &amp;&amp; this.context != null &amp;&amp; this.context.containsBean((String) name)) &#123; // 如果在Spring容器中包含bean，则返回String的Bean result = this.context.getBean((String) name); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return result; &#125; public Object put(String name, Object object) &#123; return super.put(name, object); &#125;&#125; 完整的demo参照 SpringDemoTest.java 3.3.9 增强上下文参数Context相关的api - 02自定义函数操作符获取原始的context控制上下文自定义的Operator需要直接继承OperatorBase，获取到parent即可，可以用于在运行一组脚本的时候，直接编辑上下文信息，业务逻辑处理上也非常有用。12345678910111213141516171819202122232425262728293031public class ContextMessagePutTest &#123; class OperatorContextPut extends OperatorBase &#123; public OperatorContextPut(String aName) &#123; this.name = aName; &#125; @Override public OperateData executeInner(InstructionSetContext parent, ArraySwap list) throws Exception &#123; String key = list.get(0).toString(); Object value = list.get(1); parent.put(key,value); return null; &#125; &#125; @Test public void test() throws Exception&#123; ExpressRunner runner = new ExpressRunner(); OperatorBase op = new OperatorContextPut(&quot;contextPut&quot;); runner.addFunction(&quot;contextPut&quot;,op); String exp = &quot;contextPut(&apos;success&apos;,&apos;false&apos;);contextPut(&apos;error&apos;,&apos;错误信息&apos;);contextPut(&apos;warning&apos;,&apos;提醒信息&apos;)&quot;; IExpressContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;(); context.put(&quot;success&quot;,&quot;true&quot;); Object result = runner.execute(exp,context,null,false,true); System.out.println(result); System.out.println(context); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://bruce.bugmakers.club/categories/java/"}],"tags":[{"name":"awesome","slug":"awesome","permalink":"http://bruce.bugmakers.club/tags/awesome/"},{"name":"规则引擎","slug":"规则引擎","permalink":"http://bruce.bugmakers.club/tags/规则引擎/"}]},{"title":"公开课 | 网易云课堂Java高级开发工程师(持续更新中)","slug":"网易公开课/Java高级工程师公开课","date":"2018-12-11T23:03:00.000Z","updated":"2019-03-01T07:18:20.429Z","comments":true,"path":"2018/12/12/网易公开课/Java高级工程师公开课/","link":"","permalink":"http://bruce.bugmakers.club/2018/12/12/网易公开课/Java高级工程师公开课/","excerpt":"","text":"网易云课堂Java高级开发工程师公开课索引第一期 Java高级开发工程师直播公开课 《Java高级开发工程师》直播课 《Java高级开发工程师》直播课Ⅲ 《Java高级开发工程师》直播课Ⅳ 《Java高级开发工程师》直播课Ⅴ 《Java高级开发工程师》直播课Ⅵ 《Java高级开发工程师》直播课Ⅶ 第二期 Java高级开发工程师直播课1 Java高级开发工程师直播课2 Java高级开发工程师直播课3 Java高级开发工程师直播课4 课程 内容简介 海报 offer收割机-互联网公司技术类面试技巧2019-02-22 1.揭开java班主任的神秘面纱2.网易技术大佬带你优化简历3.一个程序员面试的自我修养4.网易研发人员招聘需求分析 搞定多线程核心知识-从线程安全原子性到Lock锁接口的实现2019-02-21 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密4、JAVA高并发并发编程知识体系梳理； 资深JAVA面试题-60分钟搞透分布式一致性hash算法2019-02-20 60分钟搞透分布式一致性hash算法 P8架构师分享-10亿级负载均衡架构2019-02-19 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高并发/高可用/分布式等热门技术学习路线 网易技术面试题-高性能NIO编程详解2019-02-18 1、 BIO和NIO区别搞懂了嘛？2、 NIO支撑海量连接的原理大剖析3、 什么情况下用BIO，什么情况下用NIO？4、 高性能网络编程的正确学习姿势 大型互联网分布式系统-架构演进之路2019-01-29 大型互联网分布式系统 - 架构演进之路 高性能系统优化之请求合并让性能提升数十倍2019-01-27 1、 缓存并不是系统优化的唯一手段2、 合并多个用户的请求，发挥批量处理的高性能优势3、 利用JAVA多线程技术，实现性能倍增 让技术不再生涩难懂-Spring+事务，原理就是这么简单2019-01-26 1、清晰理解分布式事务之困难2、不要再答不出两阶段提交-XA规范3、彻底搞清楚JTA是什么4、分布式事务不再难，熟练掌握Spring中JTA的使用！ SpringBoot让你的代码更优雅-彻底搞懂auto-configuration2019-01-25 1、spring boot 参数配置与使用2、如何让配置与程序分离——你必须知道的spring boot参数配置规则3、如何在你的代码中方便的使用配置参数4、关于spring boot … 从Spring中学习设计模式这三个步骤让你你熟练运用设计模式2019-01-24 1、前人总结的那些代码设计原则2、识别代码中那些“坏味道”3、通过设计模式来改进你的代码4、Spring框架源码中那些设计模式 挑战JDK源码面试-J.U.C并发编程工具类原理学习2019-01-23 1、 3W1H学习方法分享2、 如何用多线程优化你的业务代码；3、知其然也要知其所以然，线程技术原理剖析；4、JAVA多线程并发编程学习路线图； 你不知道的线程池原理分析和API解读2019-01-22 上万并发的程序设计中，开多少线程合适？知其所以然-线程池原理揭秘如何正确使用JAVA并发包中的线程池APIJAVA高并发并发编程知识体系梳理 SpringBoot极速开发-360度无死角揭秘Starter机制2019-01-21 starter让开发变得如此简单starter原理揭秘开发自己的starter直播讲师：mike 架构师全方位剖析，10亿级访问量网站的负载均衡架构2019-01-20 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高并… 5年JAVA开发，被这道Redis面试题筛下来Redis底层探秘之旅2019-01-19 1、 Redis经典面试题分享；2、 Redis原理学习方式；3、 带你自己实现Redis的JAVA客户端；4、 拓展：Redis主从复制原理浅析5、 Redis中蕴藏着的那些分布式系… 带你搞定多线程-并发编程之volatile关键字2019-01-18 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密4、JAVA高并发并发编程知识体系梳理； 饿了么外卖场景，分布式事务解决方案实录2019-01-17 1. 隐藏在业务场景中的分布式事务问题；2. 分布式事务处理的核心理念3. 如何真正将分布式事务技术落地4. 实战：结合外卖项目下单分单场景解决事务问题5. 分… BAT技术分析，前后端分离架构技术内幕2019-01-16 1、 互联网技术细分的背景下，“大前端”的概念;2、 前后端分离下，用户状态校验方式的调整;3、 4个步骤带你掌握动静分离核心技能；4、 跨域问题最简解决方案… 缓存失效导致系统挂掉！如何解决这个深坑2019-01-15 1、 缓存与高并发这对好基友；2、缓存使用，设计不当导致的隐性问题；3、针对具体问题，详解多种解决方案；4、系统架构没有银弹，高并发系统开发核心理念梳理… 大型系统设计核心之一-分布式订单号生成策略2019-01-14 1、 大型分布式系统下，订单号生成要求2、 主流生成策略逐个讲解3、 多种方案之如何进行技术选型4、 给你做互联网分布式系统开发技术路线规划 还搞不懂Tomcat原理就晚了-带你从零手写Tomcat2019-01-13 1、 Tomcat宏观概念梳理2、 实现Tomcat的具体步骤3、 90分钟写一个能部署war包的tomcat 基于Redis的分布式锁实现方案2019-01-12 1、 锁的概念2、 分布式锁的应用场景3、 Redis实现分布式锁的步骤4、 分布式技术和多线程安全技术知识点梳理 90分钟掌握分布式锁应用与实现2019-01-11 1、3W1H学习方法，为什么需要分布式锁？2、分布式锁的实现方式有哪些？3、基于zookeeper的分布式锁如何实现；4、互联网分布式系统架构技能分享； 安全架构之Https，让你的隐私数据不再暴露2019-01-10 1、 安全之殇 - 分享互联网安全问题2、 Https是如何解决这个问题的3、 信息加密技术剖析4、 教你搭建生产环境上的https环境 BAT大型分布式系统-架构演进之路2019-01-09 1、大型互联网系统架构演进过程2、大型互联网系统架构核心技术3、架构演进思想总结4、架构设计误区 从容应对亿级大数据存储-分库分表技术实战2019-01-08 1、 数据量太多，SQL查询慢怎么办？2、 数据库分库分表概念详解3、 Mycat分布式数据库中间件介绍4、 手把手教你学会用Mycat应对海量数据。 分布式系统开发实战篇-TCC分布式事务实现2018-12-28 1、 分布式系统下高难度的事务问题分析2、 生产级解决方案思路分析3、 老司机手把手分析TCC具体实现过程4、 网易内部JAVA技术栈分析 思维决定高度-老司机和你说说高并发系统开发那些套路2018-12-27 1、三思后行，搞懂高并发核心思路；2、实战分析电商经典高并发应用场景3、架构有方法之从流量角度出发来演进架构4、高并发系统开发常用到的那些中间件 听完这堂手写SpringMVC直播课，硬刚Spring原理面试题2018-12-26 1、 SpringMVC核心处理流程梳理2、 实现一个自己的mvc框架3、 总结技巧，Spring原理不再难懂 多线程面试题系列（一）2018-12-25 1、 如何学习多线程？2、 线程状态3、 线程中止4、 线程通信 让你的数据库抗更大的压力-读写分离从设计到实现2018-12-24 1、 数据库压力太大，如何优化？2、 什么是读写分离？3、 实现读写分离的那些解决方案；4、 60分钟带你实现数据读写分离； 带你搞定多线程-并发编程之volatile关键字2018-12-23 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密；4、JAVA高并发并发编程知识体系梳理； 互联网分布式系统核心组件-详解ELK日志管理体系2018-12-22 1、 单独的日志文件不再适应分布式系统2、 一种满足日志管理、线上问题分析的解决方案3、 老司机手把手分析企业级日志管理方案ELK具体实现4、 网易内部JAVA技… 挑战JDK源码面试-J.U.C并发编程工具类原理学习2018-12-21 1、 3W1H学习方法分享2、 如何用多线程优化你的业务代码；3、知其然也要知其所以然，线程技术原理剖析；4、JAVA多线程并发编程学习路线图； 高并发流量削峰-这么做让系统性能提升50倍以上2018-12-20 1、 高并发流量下，系统故障真实演练2、 应对高并发场景的方式3、 分布式消息中间件Rabbitmq工作流程剖析4、 通过Rabbitmq实现高并发流量削峰性能提升 从Spring中学习设计模式这三个步骤让你你熟练运用设计模式2018-12-19 1、前人总结的那些代码设计原则2、识别代码中那些“坏味道”3、通过设计模式来改进你的代码4、Spring框架源码中那些设计模式 一线互联网公司全方位监控架构-构建分布式调用链路追踪系统2018-12-18 1、大型分布式项目链路监控该如果架构 2、分布式调用链的原理剖析 3、SkyWalking实现分布式链路跟踪 搞懂JMM内存模型就是今晚的事2018-12-17 1、 了解JAVA运行时数据区2、 搞懂堆内存和线程栈的区别3、 JAVA堆内存模型详解 高性能缓存可靠性设计-Redis高可用集群实战2018-12-16 1、了解单实例redis带来的问题 2、redis主从架构搭建 3、大型互联网公司redis高可用方法 4、redis哨兵模式实现高可用 Hystrix请求合并,让性能瞬间提升十倍2018-12-15 1、 缓存并不是系统优化的唯一手段2、 合并多个用户的请求，发挥批量处理的高性能优势3、 利用JAVA多线程技术，实现性能倍增 大型系统设计核心之一分布式订单号生成策略2018-12-14 1、 大型分布式应用中，对业务编号的要求；2、 实现单号生成器的几种方式；3、 架构师技术选型工作之多种方案对比； JDK源码就该这么学-从框架设计者角度学习HashMap2018-12-13 1、 老司机分析源码学习的方法2、 提升自己的思维，从设计者的角度看待问题3、 HashMap源码分析4、 常用JDK工具类源码学习路线 10年老司机开车-60分钟掌握分布式锁应用与实现2018-12-12 1、3W1H学习方法，为什么需要分布式锁？2、分布式锁的实现方式有哪些？3、基于zookeeper的分布式锁如何实现；4、互联网分布式系统架构技能分享； 架构师全方位剖析，10亿级访问量网站的负载均衡架构2018-12-11 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高并… 实战问题解决方案-高性能集群session共享2018-12-10 1、传统单体项目演进集群部署后遇到的问题；2、利用nginx反向代理和负载均衡搭建集群环境；3、集群下session共享原理剖析及解决方法； 支持海量并发连接的秘密-NIO高性能编程实战课2018-12-09 1、 BIO和NIO区别搞懂了嘛？2、 NIO支撑海量连接的原理大剖析3、 什么情况下用BIO，什么情况下用NIO？4、 高性能网络编程的正确学习姿势 分布式系统架构核心组件-统一配置中心2018-12-08 1、传统项目配置管理无法适应分布式系统架构2、 分布式统一配置中心核心概念分析3、 从实际场景出发，解决你的分布式系统难题 一个缓存设计的漏洞，让系统瞬间宕机2018-12-07 1、 高并发下，你的缓存设计真能抗住高并发？2、 详解一个黑客攻击的惯用手法；3、 这几种方案助你真正完善的缓存系统；4、 JAVA缓存架构整体知识图谱； 从容应对亿级大数据存储-分库分表技术实战2018-12-06 1、 数据量太多，SQL查询慢怎么办？2、 数据库分库分表概念详解；3、 Mycat分布式数据库中间件介绍；4、 手把手教你学会用Mycat应对海量数据； 缓存失效导致系统挂掉！如何解决这个深坑2018-12-05 1、缓存与高并发这对好基友；2、 缓存使用，设计不当导致的隐性问题；3、 针对具体问题，详解多种解决方案；4、系统架构没有银弹，高并发系统开发核心理念梳… 安全架构之Https，让你的隐私数据不再暴露2018-12-04 1、 安全之殇 - 分享互联网安全问题2、 Https是如何解决这个问题的3、 信息加密技术剖析4、 教你搭建生产环境上的https环境 最热门分布式技术：dubbo-rpc核心原理剖析2018-12-03 1、 为什么要用dubbo框架2、 dubbo框架本质是什么？3、 手把手带你写出dubbo核心逻辑4、 Dubbo完整知识体系梳理 基于Redis的分布式锁实现方案2018-12-02 1、 锁的概念2、 分布式锁的应用场景3、 Redis实现分布式锁的步骤4、 分布式技术和多线程安全技术知识点梳理 分布式系统RPC技术核心之TCP粘包拆包解决方案2018-12-01 1、 RPC技术分析2、 netty框架5分钟上手使用3、 网络知识快速掌握4、 每个RPC都必须解决的粘包拆包问题 代码优雅系列之手写注解2018-11-30 1、 如何从繁琐的业务代码中解脱？2、 学习Spring等顶级框架的代码设计；3、 15分钟了解注解内部原理；4、 手把手带你进行业务代码封装； 还搞不懂Tomcat原理就晚了-带你从零手写Tomcat2018-11-29 1、 Tomcat宏观概念梳理2、 实现Tomcat的具体步骤3、 90分钟写一个能部署war包的tomcat 分布式系统session共享机制全方位剖析2018-11-28 1、应对海量请求之快速构建应用集群2、session一致性问题剖析3、常用session共享解决方案介绍 高并发缓存架构之服务器代理缓存2018-11-27 1、 海量读取请求，数据库性能分析2、 巧妙利用http协议实现缓存3、 高性能缓存之Nginx高级特性的使用4、 互联网缓存架构整体技术剖析 不懂源码必看之作：手写springmvc2018-11-26 1、 SpringMVC核心处理流程梳理2、 实现一个自己的mvc框架3、 总结技巧，Spring原理不再难懂 5年JAVA开发，被这道Redis面试题筛下来Redis底层探秘之旅2018-11-25 1、 Redis经典面试题分享；2、 Redis原理学习方式；3、 带你自己实现Redis的JAVA客户端；4、 拓展：Redis主从复制原理浅析；5、 Redis中蕴藏着的那些分布式… 轻松搞定数据库读写分离2018-11-24 1、 数据库压力太大，如何优化？2、 什么是读写分离？3、 实现读写分离的那些解决方案。4、 30分钟带你实现数据读写分离 揭开JAVA热加载神秘面纱-Tomcat在用的热加载方案2018-11-23 1、JAVA程序运行过程梳理；2、手把手带你实现不重启JVM，执行最新修改代码；3、 验证Tomcat内部热加载功能的实现原理 高并发流量削峰-系统性能瞬间提升50倍以上2018-11-22 1、 高并发流量下，系统故障真实演练2、 应对高并发场景的方式3、 分布式消息中间件Rabbitmq工作流程剖析4、 通过Rabbitmq实现高并发流量削峰性能提升 架构师全方位剖析，10亿级访问量网站的负载均衡架构2018-11-21 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高… 从容应对亿级大数据存储-分库分表技术实战2018-11-20 1、 数据量太多，SQL查询慢怎么办？2、 数据库分库分表概念详解3、 Mycat分布式数据库中间件介绍4、 手把手教你学会用Mycat应对海量数据。。 JDK源码学习有方法！J.U.C并发编程工具类原理剖析2018-11-19 1、 3W1H学习方法分享2、 如何用多线程优化你的业务代码；3、知其然也要知其所以然，线程技术原理剖析；4、JAVA多线程并发编程学习路线图。 BAT技术分析，前后端分离架构技术内幕2018-11-18 1、 互联网技术细分的背景下，“大前端”的概念;2、 前后端分离下，用户状态校验方式的调整;3、 4个步骤带你掌握动静分离核心技能；4、 跨域问题最简解决方案… 压榨数据库极致性能-Mysql数据库优化及SQL优化2018-11-17 1、 MySQL在使用中常见性能瓶颈分析2、 EXPLAIN执行计划语句的原理讲解3、 索引的实际应用与注意事项4、 对Mysql进行缓存，I/O，通信等调优 电商系统核心技术内幕-高并发订单号生成策略揭秘2018-11-16 1、 大型分布式系统下，订单号生成要求2、 主流生成策略逐个讲解3、 多种方案之如何进行技术选型4、 给你做互联网分布式系统开发技术路线规划 带你搞定多线程-并发编程之volatile关键字2018-11-15 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密4、JAVA高并发并发编程知识体系梳理； 饿了么外卖场景，分布式事务解决方案实录2018-11-14 1. 隐藏在业务场景中的分布式事务问题；2. 分布式事务处理的核心理念3. 如何真正将分布式事务技术落地4. 实战：结合外卖项目下单分单场景解决事务问题5. 分… 电商系统和分布式消息中间件，不得不说的故事2018-11-13 1、 经典电商业务场景详解2、 分布式消息中间件RabbitMQ核心概念梳理；3、 电商系统中MQ中间件的架构设计图一览；4、 必看的几个电商业务设计关键点； 【实战篇】Spring框架源码中的设计模式2018-11-12 1、前人总结的那些代码设计原则2、识别代码中那些“坏味道”3、通过设计模式来改进你的代码4、Spring框架源码中那些设计模式 大型互联网分布式系统架构演进之路2018-11-11 大型互联网系统架构演进过程大型互联网系统架构核心技术架构演进思想总结架构设计误区 高并发秒杀系统架构设计和实现2018-11-10 1、三思后行，搞懂高并发核心思路；2、实战分析电商经典高并发应用场景3、架构有方法之从流量角度出发来演进架构4、高并发系统开发常用到的那些中间件 120分钟掌握分布式锁应用与实现2018-11-09 1、3W1H学习方法，为什么需要分布式锁？2、分布式锁的实现方式有哪些？3、基于zookeeper的分布式锁如何实现；4、互联网分布式系统架构技能分享； 缓存失效导致系统挂掉！如何解决这个深坑2018-11-08 1. 缓存与高并发这对好基友；2. 缓存使用，设计不当导致的隐性问题；3. 针对具体问题，详解多种解决方案；4. 系统架构没有银弹，高并发系统开发核心理念梳理","categories":[{"name":"JAVA高级","slug":"JAVA高级","permalink":"http://bruce.bugmakers.club/categories/JAVA高级/"}],"tags":[{"name":"公开课","slug":"公开课","permalink":"http://bruce.bugmakers.club/tags/公开课/"}]},{"title":"vue | VUE组件 - 回到顶部","slug":"vue/vue组件 - 回到顶部","date":"2018-06-14T12:12:00.000Z","updated":"2019-01-08T15:07:02.751Z","comments":true,"path":"2018/06/14/vue/vue组件 - 回到顶部/","link":"","permalink":"http://bruce.bugmakers.club/2018/06/14/vue/vue组件 - 回到顶部/","excerpt":"","text":"组件效果图 组件使用示例 backTopDemo.vue1234567891011121314151617&lt;template&gt; &lt;div style=&quot;height: 2000px;&quot;&gt; &lt;back-top&gt;&lt;/back-top&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BackTop from &apos;../components/common/backTop&apos;export default &#123; name: &apos;backTopDemo&apos;, components: &#123;BackTop&#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 组件源码 backTop.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;transition name=&apos;slide-fade&apos;&gt; &lt;div class=&apos;page-component-up&apos; v-if=&apos;isShow&apos; @click=&apos;getTop&apos;&gt; &lt;i class=&quot;el-icon-caret-top&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;BackTop&apos;, data () &#123; return &#123; isShow: false &#125; &#125;, methods: &#123; // 添加样式，鼠标hover上去，改变颜色 addhoverClass (e) &#123; if (e.type === &apos;mouseover&apos; &amp;&amp; this.$el.classList) &#123; this.$el.classList.add(&apos;hover&apos;) &#125; else if (e.type === &apos;mouseout&apos; &amp;&amp; this.$el.classList) &#123; this.$el.classList.remove(&apos;hover&apos;) &#125; &#125;, showIcon () &#123; if (document.documentElement.scrollTop &gt; 100) &#123; this.isShow = true this.$el.addEventListener(&apos;mouseover&apos;, this.addhoverClass) this.$el.addEventListener(&apos;mouseout&apos;, this.addhoverClass) &#125; else if (document.documentElement.scrollTop &lt; 100) &#123; this.isShow = false &#125; &#125;, getTop () &#123; let timer = setInterval(() =&gt; &#123; let top = document.documentElement.scrollTop let speed = Math.ceil(top / 5) document.documentElement.scrollTop = top - speed if (top === 0) &#123; clearInterval(timer) &#125; &#125;, 20) &#125; &#125;, mounted () &#123; window.addEventListener(&apos;scroll&apos;, this.showIcon) &#125;, beforeDestroy () &#123; window.removeEventListener(&apos;scroll&apos;, this.showIcon) &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; rel=&quot;stylesheet/scss&quot;&gt;.slide-fade-enter-active &#123; transition: all .1s ease;&#125;.slide-fade-leave-active &#123; transition: all .1s cubic-bezier(1.0, 0.3, 0.8, 1.0); opacity: 0;&#125;.slide-fade-enter, .slide-fade-leave-to /* .slide-fade-leave-active 在低于 2.1.8 版本中 */ &#123; // transform: translateY(-20px); opacity: 0;&#125;.page-component-up &#123; background-color: #67C23A; position: fixed; right: 3rem; bottom: 8rem; width: 50px; height: 50px; border-radius: 25px; cursor: pointer; opacity: .3; transition: .3s; text-align: center; z-index: 999;&#125;.el-icon-caret-top &#123; font-size: 36px; margin-top: 7px; color: #FFFFFF; text-align: center; z-index: 1000&#125;.hover &#123; background-color: #409EFF;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://bruce.bugmakers.club/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/tags/前端/"}]},{"title":"vue | VUE - 教程收集","slug":"vue/vue基础","date":"2018-05-30T02:33:00.000Z","updated":"2019-01-08T15:07:02.766Z","comments":true,"path":"2018/05/30/vue/vue基础/","link":"","permalink":"http://bruce.bugmakers.club/2018/05/30/vue/vue基础/","excerpt":"","text":"主要内容整理自前端君的微信公众号：web前端教程，本文仅做个内容一览和跳转（跳转到原作者公众号文章） 最新更新：无论学习什么，多从官网渠道获取信息，vue中文官网：https://cn.vuejs.org/index.html VUE 基础：《vue2.0基础系列》目录大全 进阶：《vue2.0进阶系列》 ES 6前端君除了vue教程外，还做了es6的系列教程，vue是基于es开发的，所以学习es也是蛮有必要的，至于es是什么，自行学习哈 ES6：《ES6系列连载》 其他一个前端的在线文档：http://docs.720ui.com/api_docs_web.html","categories":[{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://bruce.bugmakers.club/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/tags/前端/"}]},{"title":"tools | 推荐一款本地文件检索工具：Launchy","slug":"tools/tools-launchy","date":"2018-04-25T14:10:00.000Z","updated":"2019-01-08T15:07:02.651Z","comments":true,"path":"2018/04/25/tools/tools-launchy/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/25/tools/tools-launchy/","excerpt":"","text":"1、演示 2、优点 轻量级，安装后占用空间才10+MB 操作简单，体验很好 免费 3、下载地址http://www.launchy.net/download.php#windows","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"tools | 推荐一款漂浮截图工具：SETUNA","slug":"tools/tools-setuna","date":"2018-04-23T05:10:00.000Z","updated":"2019-01-08T15:07:02.666Z","comments":true,"path":"2018/04/23/tools/tools-setuna/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/23/tools/tools-setuna/","excerpt":"","text":"1、演示 2、优点 轻量级，整个软件大小只有1.17MB 操作简单，体验很好 免费 3、下载地址 我的百度云 https://pan.baidu.com/s/1UKG2zZ0CYVOwBJQGy21C4w 类似小工具1）pureref，官网：https://www.pureref.com/ 推荐文章：https://cloud.tencent.com/developer/news/44018","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"tools | 推荐一款gif录制工具：LICEcap","slug":"tools/tools-liceecap","date":"2018-04-21T15:30:00.000Z","updated":"2019-01-08T15:07:02.738Z","comments":true,"path":"2018/04/21/tools/tools-liceecap/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/21/tools/tools-liceecap/","excerpt":"","text":"1、演示 2、优点 轻量级，整个软件大小只有1.17MB 操作简单，体验很好 免费 3、下载地址 官网 https://www.cockos.com/licecap/ 我的github仓库 https://github.com/BruceOuyang/issuelist/blob/master/tools/licecap126-install.zip 我的百度云 https://pan.baidu.com/s/13dNnFKf1ASq7ysMBjfcY4w","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"设计模式 | 开篇","slug":"design-pattern/00-boy-learning-design-pattern","date":"2018-04-19T23:13:00.000Z","updated":"2019-01-06T17:34:44.194Z","comments":true,"path":"2018/04/20/design-pattern/00-boy-learning-design-pattern/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/20/design-pattern/00-boy-learning-design-pattern/","excerpt":"","text":"Bruce Ouyang 正在学习《设计模式Java版》 http://woquanke.com/books/gof/这本书个人学习的主要内容以及对应源码记录在https://github.com/BruceOuyang/boy-design-pattern目录下 初衷 系统的学习一遍设计模式 书的原链接https://gof.quanke.name 这个地址貌似正常情况下访问不了，习惯了markdown不想去看csdn上旧风格的文章（quanke大神的csdn博客上也有一份设计模式）,故在此仓库copy一份，方便大家访问和一起学习 最新更新，原作者提供了新域名访问地址： http://woquanke.com/books/gof/ ，国内访问无压力 融入一点自己的风格：我将刘伟大神的设计模式一书内容分散在代码的各个包里边，方便阅读 原文中有一些练习，就在这个仓库的源码中做掉 二十四种设计模式一览 以下文章持续更新中… 创建型 六个创建型模式 SEQ1 - 简单工厂模式 Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 SEQ2 - 工厂方法模式 Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】 SEQ3 - 抽象工厂模式 Abstract Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】 SEQ4 - 单例模式 Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 SEQ5 - 原型模式 Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ6 - 建造者模式 Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】 结构型 七个结构型模式 SEQ1 - 适配器模式 Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】 SEQ2 - 桥接模式 Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ3 - 组合模式 Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 SEQ4 - 装饰模式 Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ5 - 外观模式 Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】 SEQ6 - 享元模式 Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 SEQ7 - 代理模式 Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 行为型 十一个行为型模式 SEQ01 - 职责链模式 Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 SEQ02 - 命令模式 Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 SEQ03 - 解释器模式 Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】 SEQ04 - 迭代器模式 Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 SEQ05 - 中介者模式 Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 SEQ06 - 备忘录模式 Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】 SEQ07 - 观察者模式 Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 SEQ08 - 状态模式 State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ09 - 策略模式 Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 SEQ10 - 模板方法模式 Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 SEQ11 - 访问者模式 Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 复习 设计模式趣味学习 设计模式于足球 设计模式综合应用实例 多人联机射击游戏 数据库同步服务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://bruce.bugmakers.club/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://bruce.bugmakers.club/tags/设计模式/"}]},{"title":"免费博客 | Hexo搭建博客并部署到Github Pages服务","slug":"hexo/hexo-githubpages-blog","date":"2018-04-19T14:05:00.000Z","updated":"2019-01-08T15:07:02.688Z","comments":true,"path":"2018/04/19/hexo/hexo-githubpages-blog/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/19/hexo/hexo-githubpages-blog/","excerpt":"","text":"本文实践的操作系统是windows 10，其他OS的可以当做参考用 一、Hexo搭建博客1. 环境准备 下载并安装 nodejs 下载并安装 git 直接上官网看指引即可，如有疑问可以在评论中留言说明 2. Hexo初始化博客 在命令行窗口中执行下列命令 使用npm安装hexo 1npm install -g hexo-cli 初始化你的博客项目 执行命令123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install &lt;folder&gt; 是你本地的文件目录，例如：F:\\bruce\\hexo\\bugmakerBlog，如果不写，则会在执行命令的当前目录初始化一个hexo博客项目 初始化的过程中会去github上下载一些东西，比如说默认的主题 landscape 之类的，需要等个几分钟 初始化完成后，你会得到一个这样的项目目录结构： _config.yml网站的主要配置文件，可以配置你网站的大部分信息。【配置参考说明】 简单的配置示例 key 说明 示例 title 网站的名字 BuG制造者联盟官方主页 author 网站的作者 Bruce language 语言设置 zh-CN package.json应用数据。 scaffolds目录模板目录，你新建一篇博客的时候会以这个目录中的模板文件来创建。 source目录资源目录，你新建的博客都存储在这里。在生成页面的时候，hexo会忽略掉命名为 _ 开头的文件或文件夹， _post 除外，会将 .md 和 .html 后缀的文件按主题生成页面，并复制到public目录下，其他后缀的文件则直接复制过去，不进行额外转换操作。 themes目录主题目录，你可以为自己的网站挑选好看的主题，然后在 _config.yml 文件中指定主题即可。 写一篇博客1hexo new [layout] &lt;title&gt; hexo new 会在 source目录 中创建一个以 &lt;title&gt; 命名的 .md 文件[layout] 是默认布局，在 scaffolds目录 下定义的，默认布局在 _config.yml 中指定，初始化的默认布局是 post&lt;title&gt; 是博客的标题，博客的标题可以在生成的 .md 文件中修改 示例1hexo new post My First Blog 生成页面并运行你的博客12hexo ghexo s -p 80 hexo g 是hexo生成页面指令 hexo generate 的缩写hexo s 是hexo启动本地服务的指令，默认端口是4000-p 80 是指定端口号80 默认访问地址 http://localhost:4000指定80端口访问地址 http://localhost 3. 切换博客主题在上一步中，我们看到的博客使用的主题是默认的 landscape 主题，hexo为我们提供了很多的主题可以选择，访问网站 https://hexo.io/themes/ 挑选自己喜欢的主题 将挑选好的主题 clone 到 theme目录 下，主题目录下也有一个 _config.yml 配置文件，这个配置文件即主题相关配置，具体根据主题的wiki上的说明来操作 在 _config.yml 中，设置 theme 属性的值为 theme目录 下的某一款主题即可，直接写目录下的文件夹名字 示例： clone主题到 theme目录 1git clone https://github.com/klugjo/hexo-theme-alpha-dust.git 修改根目录下的 _config.yml 配置文件，设置 theme 值 1theme : hexo-theme-alpha-dust 重新生成并启动本地服务 12hexo ghexo s -p 80 效果图 二、了解Github Pages服务GitHub Pages 网站：https://pages.github.com/ 1. 有什么用 Websites for you and your projects. 为你和你的项目提供一个网站Hosted directly from your GitHub repository. 直接托管存储在你的github仓库Just edit, push, and your changes are live. 只管去编辑提交代码到仓库，你的网站都会即时更新。 2. 怎么玩的 步骤其实很简单，在 Github Pages上都有如果你还没有github的账号，那需要先注册一个 第一步：在github上创建一个仓库，命名为 username.github.io username就是你的github用户名，注意不是登录账号，我仓库名字是 BuGMakerClub.github.io 第二步：将刚刚创建的仓库 clone 到本地，如 F:\\bruce\\bruce-private-github\\BuGMakerClub.github.io 12cd F:\\bruce\\bruce-private-github\\git clone https://github.com/BuGMakerClub/BuGMakerClub.github.io.git 第三步：在 clone 下来的项目中，创建一个 index.html，内容可以是 Hello World 12cd BuGMakerClub.github.ioecho &apos;Hello World&apos; &gt; index.html 第四步：提交代码，把刚创建的 index.html 文件 commit &amp; push 到你的 github仓库中 第五步：结束，你可以直接访问 https://username.github.io 访问你的网站了，我的网站地址是 https://BuGMakerClub.github.io 第六步：设置自己的个性化域名 如果你有自己的域名，可以在仓库的设置中绑定自己的个性化域名，然后在域名管理中心设置一个域名解析地址，这样就可以用个性化域名来访问github pages服务商的网页了 三、结合Hexo博客和Github Pages服务 参考：https://hexo.io/docs/deployment.html hexo的配置中，有一个 deploy 指令，可以将生成的博客网站部署到github仓库中，这样就形成两者的结合关系了。 具体操作如下 安装 hexo-deployer-git 插件1npm install hexo-deployer-git --save 修改根目录下的 _config.yml 配置文件 123deploy: type: git repo: https://github.com/BuGMakerClub/BuGMakerClub.github.io.git 执行 deploy 指令发布代码 1hexo d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/categories/hexo/"}],"tags":[{"name":"免费博客","slug":"免费博客","permalink":"http://bruce.bugmakers.club/tags/免费博客/"},{"name":"github pages","slug":"github-pages","permalink":"http://bruce.bugmakers.club/tags/github-pages/"}]},{"title":"免费博客 | Hello Hexo","slug":"hexo/hello-world","date":"2018-04-18T21:05:00.000Z","updated":"2019-01-08T15:07:02.709Z","comments":true,"path":"2018/04/19/hexo/hello-world/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/19/hexo/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/categories/hexo/"}],"tags":[{"name":"免费博客","slug":"免费博客","permalink":"http://bruce.bugmakers.club/tags/免费博客/"},{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/tags/hexo/"}]},{"title":"敏捷开发 | Scrum 实践分享","slug":"agile/敏捷开发","date":"2017-08-15T02:00:00.000Z","updated":"2019-04-24T09:18:29.364Z","comments":true,"path":"2017/08/15/agile/敏捷开发/","link":"","permalink":"http://bruce.bugmakers.club/2017/08/15/agile/敏捷开发/","excerpt":"","text":"1 scrum processresource：Scrum介绍-LukeShen.pptx 2 daily meeting info collector resource：sprint-standmeeting-demo.xls","categories":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://bruce.bugmakers.club/categories/敏捷开发/"}],"tags":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://bruce.bugmakers.club/tags/敏捷开发/"},{"name":"Scrum","slug":"Scrum","permalink":"http://bruce.bugmakers.club/tags/Scrum/"}]}]}