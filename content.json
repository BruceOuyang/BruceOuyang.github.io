{"meta":{"title":"BuGMaker' Bruce Ouyang","subtitle":null,"description":null,"author":"Bruce Ouyang","url":"http://bruce.bugmakers.club"},"pages":[{"title":"关于","date":"2018-04-19T06:13:36.000Z","updated":"2019-05-04T14:14:47.924Z","comments":true,"path":"about/index.html","permalink":"http://bruce.bugmakers.club/about/index.html","excerpt":"","text":"BuGMakersClub希望有想法的小伙伴们可以集结在一起，让所做的事情变得更有价值。 如果你对 BuGMakersClub 感兴趣，可以加我们的QQ群 111915819。"},{"title":"Categories","date":"2018-04-19T13:55:28.560Z","updated":"2018-04-17T23:19:52.693Z","comments":true,"path":"categories/index.html","permalink":"http://bruce.bugmakers.club/categories/index.html","excerpt":"","text":""},{"title":"Project","date":"2019-05-04T14:14:47.929Z","updated":"2019-05-04T14:14:47.929Z","comments":true,"path":"project/index.html","permalink":"http://bruce.bugmakers.club/project/index.html","excerpt":"","text":""},{"title":"我的简历| 2019版 | 欧阳强强 | 176-0212-5174 | Java高级工程师 | 7年工作经验","date":"2019-07-15T07:26:44.923Z","updated":"2019-07-15T07:26:44.905Z","comments":true,"path":"about/resume.html","permalink":"http://bruce.bugmakers.club/about/resume.html","excerpt":"","text":"联系方式 手机：17602125174 Email：oiiopro@live.cn QQ：1276541098 微信号：oiiopro 个人信息 欧阳强强(Bruce Ouyang) / 男 / 1992 专科 / 长沙学院 / 计算机应用技术 工作年限：7年 期望职位：Java高级程序员，架构师 期望薪资：面议 期望城市：上海 Github：http://github.com/bruceouyang 个人博客：http://bruceouyang.github.io 简书：https://www.jianshu.com/u/8bc5f4428ca2 CSDN：https://blog.csdn.net/boybruce 工作经历宝德融资租赁 （ 2018年5月 ~ 至今 ）工作时长：1年离职原因：追求自己的职业价值 德易车金融项目简述一个主打二手车交易市场的车金融平台级应用，从业务上分为几个模块：销售、风控、信审、金融产品、合同、撮配导标、财务和贷后，完整的业务流贯穿以上所有模块。 我以高级JAVA工程师身份加入团队，在项目初期在信审组做研发支持，后主要负责金融产品模块，角色是主开发（模块负责人）。 总结 做的比较出色：快速响应支持业务方的需求、老项目梳理以及新功能研发有较完备的文档输出、组员关系维护的良好工作热情高。 最困难的问题：在快速迭代的过程中对自己情绪的把控做的不是很好，跟产品经理之间会产生一些矛盾点。 当时解决方式：保持多沟通，给出建议产品经理和研发互相做一些妥协，确保新的业务功能如期上线。 其他总结：在工作表现上，领导给予较高的评价，例如做事情有条理、职业素养高、最大的优点是服务意识好。 掘新科技(上海)有限公司 （ 2015年8月 ~ 2018年4月 ）工作时长：2年8个月离职原因：掘新科技是一家外包公司，长期呆下去不利于个人成长 海银基金平台项目（互联网金融）简述一个与基金公司合作的基金中介平台。 个人作为高级JAVA工程师，加入团队，参与研发并负责一个6个人小团队的管理。 总结 做的比较出色：对系统分析文档整理的比较清晰，帮助同事熟悉业务和系统更顺利。 最困难的问题：刚上手的时候没有任何文档，给team成员带来了极大的困扰。 当时解决方式：我在熟悉项目的过程中，及时记录我看过的内容并整理成文档，然后分享给我的同事，并且把这个方法也推荐给他们。 其他总结：在项目过程中发现team管理不是很合理，跟领导沟通并推荐使用半敏捷的模式来做团队管理，得到了领导的认同。 博泰PAAS云平台项目（车联网）简述这是一个车联网项目，项目中包含的元素有很多，主要包含两个核心模块：云平台、车载终端设备。 在团队中，我的角色是JAVA工程师，主要负责支持云服务中的基础服务研发工作，TSP和OTA部分。 总结 做的比较出色：积极配合领导的工作，有问题及时沟通，能够按时按量的完成领导安排的工作。 最困难的问题：有很多没用过的新技术，如springboot、springcloud、zk、kafka。 当时解决方式：上官网找api文档学习、快速精准的阅读网上的博客，在github&amp;gitee上找相关源码学习。 其他总结：在这个项目中，我最自豪的是短时间内学习了很多新东西，还做了一回讲师，内部分享了《SpringCloud任务跟踪服务Sleuth组件》，在当年收到了公司发的教师节礼物。 德晟资本财富农场项目（互联网金融）简述这是一个P2P平台项目。 在团队中，我的角色是JAVA工程师，主要负责平台服务端的研发工作，也会参与一些营销活动的研发。 总结 做的比较出色：积极配合领导的工作，有问题及时沟通，能够按时按量的完成领导安排的工作。 最困难的问题：在做营销活动的时候，经常碰到刷活动的羊毛党，经常要与羊毛党斗智斗勇。 当时解决方式：后台做数据监控，封IP。 其他总结： 文聪信息科技有限公司 （ 2012年9月 ~ 2015年8月 ）工作时长：2年11个月离职原因：核心项目被收购，团队解散 艾特网车载WiFi项目简述这是一个车辆网的项目。 在团队中，我的最终角色是公司的首席java工程师。 总结 做的比较出色：对业务了解的比较彻底，跟多个三方公司对接都比较顺利 最困难的问题：项目前期是外包的，接手回来之后接手项目比较困难 当时解决方式：积极与乙方同事沟通，关系处理恰当保障了沟通的顺利 其他总结：这个项目中，我最自豪的是，第一次去IDC机房装机，独自完成系统搭建和软件部署，第一次担任公司技术负责人，获得了公司首席java工程师的title、获得了年度优秀个人称号 MIS系统 做的比较出色的是：跟各部门负责人沟通需求很顺利、研发小组管理有条不紊 最困难的问题： 当时解决方式： 其他总结： 艾思特科技（上海）有限公司 （ 2011年11月 ~ 2012年9月 ）工作时长：10个月离职原因：专业不对口 TMS项目二次开发 做的比较出色的是：对业务的理解比较好，SQL写的还不错，用数据库存储过程实现了核心业务。 最困难的问题：当时被分配在的项目组做的是一个java swing方向的客户端应用，自己擅长的是java web应用研发，上手比较困难。 当时解决方式：硬着头皮上，逐步调试学习源码。 其他总结：当发现专业不对口时，应当及时提出，往自己擅长的方向靠拢。 技能清单 前端：html、jsp、css、js、jQuery、EasyUI、Vue等 后端：Servlet、Struts、Spring、SpringMVC、Hibernate、MyBatis、Netty等 数据库：MSSQL、Oracle、MySQL、MongoDB WEB服务器：Tomcat、Jetty、Websphere、Nginx 服务器操作系统：WindowServer、Linux（Redhat、Centos、Ubuntu） 分布式相关: SpringCloud、Dubbo、Zookeeper、Memcached、Redis、ActiveMQ、RabbitMQ、Kafka等 开发环境：jdk1.6、jdk1.7、jdk1.8 开发工具：Eclipse、MyEclipse、 Intellij IDEA 版本管理：Git、SVN 项目构建：Maven 文档：swagger、jdoc、oscteam 荣誉 2018年 获得公司《期权授予证书》 / 宝德融资租赁 2014年 获得公司《先进个人证书》 / 文聪科技 其他教育经历 长沙学院 (2014年2月 ~ 2016年6月) / 计算机应用技术专业 / 大专文凭 欧博泰克计算机学院 (2009年7月 ~ 2011年11月) / 计算机基础和软件开发 / 中级程序员证书 培训经历 网易微专业 / Java高级开发工程师 (2018年12月 ~ 2019年12月) / 进行中 上海市人力资源和社会保障局 (2014年9月 ~ 2015年3月) / JAVA（高级）培训 / 高级Java工程师证书 华尔街英语SH14 (2012年6月 ~ 2015年3月) / 英语口语培训课程 / 华尔街英语T1级别证书 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"Tags","date":"2018-04-19T13:55:28.566Z","updated":"2018-04-17T23:19:52.693Z","comments":true,"path":"tags/index.html","permalink":"http://bruce.bugmakers.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"boy-learning-thread | 1.1.6 线程池原理","slug":"java/thread/1.1.6 线程池原理","date":"2019-10-15T16:00:00.000Z","updated":"2019-10-19T06:40:01.507Z","comments":true,"path":"2019/10/16/java/thread/1.1.6 线程池原理/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/16/java/thread/1.1.6 线程池原理/","excerpt":"","text":"相关源码：boy-learning-thread个人博客：http://bruce.bugmakers.club内容来自《网易微专业 - 高性能编程章节》 线程池原理1、为什么要用线程池线程是不是越多越好？ 1、线程在 java 中是一个对象，更是操作系统中的资源，线程创建、销毁需要时间。如果 “创建时间 + 销毁时间 &gt; 执行任务时间” 就恨不合算。 2、java 对象占用堆内存，操作系统线程占用系统内存，根据 jvm 规范，一个线程默认最大栈大小 1M，这个空间是需要从系统内存中分配的。线程过多，会消耗很多内存。 3、操作系统需要频繁切换线程上下文（大家都想被执行），线程过多会影响性能。 线程池的推出，就是为了方便的控制线程数量。 2、线程池原理 - 概念1、线程池管理器：用于创建并管理线程池，包括：创建线程池、销毁线程池、添加新任务； 2、工作线程：线程池中的线程，在没有任务时处于等待状态，可以循环的执行任务； 3、任务接口：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了：任务的入口、任务执行完后的收尾工作、任务的状态； 4、任务队列：用于存放没有处理的任务。以供一种缓冲机制。 2.1、线程池 API - 接口定义和实现类 类型 名称 描述 接口 Executor 最上层接口，定义了执行任务的方法 execute 接口 ExecutorService 继承了 Executor 接口，拓展了 Callable、Future、关闭方法 接口 ScheduledExecutorService 继承了 ExecutorService，增加了定时任务相关的方法 实现类 ThreadPoolExecutor 基础、标准的线程池实现类 实现类 ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor，实现了 ScheduledExecutorService 中相关定时任务的方法 可以认为 ScheduledThreadPoolExecutor 是最丰富的实现类。 2.2、线程池 API - 方法定义ExecutorService1234567891011121314151617181920212223242526272829303132333435// 监测 ExecutorService 是否已关闭，直到所有任务完成执行，或超时发生，或当前线程被中断 awaitTermination(long timeout, TimeUnit unit);// 执行给定的任务集合，执行完毕后，返回结果invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);// 执行给定的任务集合，执行完毕或者超时后，返回结果，其他任务终止invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit);// 执行给定的任务集合，任意一个任务执行成功后，返回结果，其他任务终止invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks);// 执行给定的任务集合，任意一个任务执行成功或超时后，返回结果，其他任务终止invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit);// 如果线程池关闭，则返回treuisShutdown();// 如果关闭后，所有任务都已经执行完毕，则返回trueisTerminated();// 优雅关闭线程池，之前已经提交的任务将被执行，但不接受新的任务shutdown();// 尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行任务的列表shutdownNow();// 提交一个用于执行的 Callable 返回任务，并返回一个 Future 对象，用于获取 Callable 执行结果submit(Callable&lt;T&gt; task);// 提交可运行任务以执行，并返回一个 Future 对象，执行结果为 nullsubmit(Runnable task);// 提交可运行任务以执行，并返回一个 Future 对象，执行结果为传入的 resultsumit(Runnable task, T result); ScheduledExecutorService1234567// 创建并执行一个一次性任务，过了延迟时间就会被执行schedule(Callable&lt;T&gt; callable, long delay, TimeUnit unit);schedule(Runnable command, long delay, TimeUnit unit);// 创建并执行一个周期性任务，过了延迟时间会第一次执行，执行过程发生异常，那么任务就停止了scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);scheduleWithFixedDelay(Runnable command, long initialDelay, long period, TimeUnit unit); scheduleAtFixedRate 方法，一次任务执行时长超过周期时间，下次任务在该次任务执行完之后，立即执行。schedualWithFixedDelay 方法，一次任务执行时间长超过周期时间，下次任务会在该次任务执行完之后，计算执行延时（再等延迟一个 period 的时长）。 2.3、线程池 API - Executors 工具类你也可以自己实例化线程池，也可以用 Executors 创建线程池的工厂类，常用方法如下： 1) newFixedThreadPool(int nThreads) 创建一个固定大小、任务队列无界的线程池。核心线程数 = 最大线程数。 2) newCachedThreadPool() 创建一个大小无界的缓存线程池。他的任务队列是一个同步队列。任务加入到池中，如果池中有空闲线程，则用空闲线程执行，如无则创建新的线程执行，池中的线程空闲超过60秒，将被销毁释放。线程数随任务的多少变化。适用于任务量不可控，且执行耗时较小的异步任务。核心线程数 = 0， 最大线程数 = Integer.MAX_VALUE 3) newSingleThreadExecutor() 只有一个线程来执行无界任务队列的单一线程池。该线程池确保任务按照加入队列的顺序一个一个一次执行。当唯一的线程因任务异常终止时，将创建一个新的线程来执行后续的任务。与 newFixedThreadPool(1) 的区别在于，单一线程池的大小在 new SingleThreadExecutor 方法中硬编码，不能再改变。 4) newScheduledThreadPool(int corePoolSize) 能定时执行任务的线程池。该池的核心线程数由参数来指定，最大线程数 = Integer.MAX_VALUE 3、线程池原理 - 任务 execute 过程1、是否达到核心线程数量？没达到，创建一个工作线程来执行任务。 2、任务队列是否已满？没满，则将新提交的任务存储在任务队列里边。 3、是否达到线程池最大数量？没达到，则创建一个新的工作线程来执行任务。 4、最后，执行拒绝策略来处理这个任务。 4、线程数量如何确定合适数量的线程？ 计算型任务：cpu数量的1~2倍。 IO型任务：根据具体的IO阻塞时长进行考量决定。 如 Tomcat 中默认的最大线程数为：200 也可以考虑根据需要在一个最小数量和最大数量间自动增减线程数。 监控CPU的使用率，如果远小于80%则使用不合理，大于也不可理，接近则表示使用良好。","categories":[{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/categories/thread/"}],"tags":[{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"},{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/tags/thread/"}]},{"title":"boy-learning-thread | 1.1.5 线程封闭之ThreadLocal和栈封闭","slug":"java/thread/1.1.5 线程封闭之ThreadLocal和栈封闭","date":"2019-10-14T16:00:00.000Z","updated":"2019-10-19T06:40:01.498Z","comments":true,"path":"2019/10/15/java/thread/1.1.5 线程封闭之ThreadLocal和栈封闭/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/15/java/thread/1.1.5 线程封闭之ThreadLocal和栈封闭/","excerpt":"","text":"相关源码：boy-learning-thread个人博客：http://bruce.bugmakers.club内容来自《网易微专业 - 高性能编程章节》 线程封闭之ThreadLocal和栈封闭线程封闭概念 背景：多线程访问共享可变数据时，涉及到线程间数据同步的问题。并不是所有时候，都要用到共享数据，所以线程封闭概念就提出来了。 线程封闭：数据都被封闭在各自的线程之中，就不需要同步，这种将数据封闭在线程之中而避免使用同步的技术称。 线程封闭具体的体现有：ThreadLocal、局部变量。 ThreadLocalThreadLocal 是 Java 里一种特殊的变量。 它是一个线程级别的变量，每个线程都有一个 ThreadLocal 就是每个线程都有了自己独立的一个变量，竞争条件彻底被消除了，在并发模式下是绝对安全的变量。 用法：1ThreadLocal&lt;T&gt; var = new ThreadLocal&lt;T&gt;(); 会自动在每一个线程上创建一个 T 的副本，副本之间彼此独立，互不影响。 可以用 ThreadLocal 存储一些参数，以便在线程中多个方法中使用，用来代替方法传参的做法。 实在难以理解，可以理解为，JVM维护了一个 Map&lt;Thread, T&gt;，每个线程要用这个 T 的时候，用当前线程去 Map 里取。——仅作为概念理解。 栈封闭（局部变量）局部变量的固有属性之一就是封闭在线程中。 它们被存储在执行线程的栈内存中，其他线程无法访问这个栈。","categories":[{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/categories/thread/"}],"tags":[{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"},{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/tags/thread/"}]},{"title":"boy-learning-thread | 1.1.4 线程通信","slug":"java/thread/1.1.4 线程通信","date":"2019-10-13T16:00:00.000Z","updated":"2019-10-18T15:30:35.296Z","comments":true,"path":"2019/10/14/java/thread/1.1.4 线程通信/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/14/java/thread/1.1.4 线程通信/","excerpt":"","text":"相关源码：boy-learning-thread个人博客：http://bruce.bugmakers.club内容来自《网易微专业 - 高性能编程章节》 线程通信通信方式要想实现多个线程之间的协同，如：线程执行先后顺序、获取某个线程的执行结果等待。涉及到线程时间的相互通信，分为下面四类： 1) 文件共享2) 网络共享3) 共享变量4) jdk 提供的线程协调 API，细分为：suspend/resume、wait/notify、park/unpark 1、文件共享12// 共享文件File file = new File(\"a.txt\"); thread1 写文件thread2 读文件 2、变量共享12// 共享变量public static String content = \"init-txt\"; thread1 写入内存变量thread2 读取内存变量 3、网络共享4、线程协作 - JDK APIJDK 中对于需要多线程协作完成某一任务的场景，提供了对应的API支持。多线程协作的典型场景是：生产者 - 消费者模型。（线程阻塞、线程唤醒） 场景示例 线程1去买包子，没有包子，则不再执行。 线程2生产包子，通知线程1继续执行。 4.1、suspend/resume 机制12thread.suspend() // 挂起thread.resume // 激活 suspend/resume 这种组合已经被 jdk 遗弃掉了，原因是容易出现死锁。 死锁场景一：同步代码块中123456789101112131415161718192021Object baozi = null;Thread consumer = new Thread(() -&gt; &#123; if (baozi == null) &#123; System.out.println(\"来晚了，卖光了\"); synchronized(this) &#123; Thread.currentThread().suspend(); &#125; &#125; System.out.println(\"买到包子，回家\");&#125;);// 包子制作中Thread.sleep(3000L);baozi = new Object();System.out.println(\"新一笼的包子做好啦\");// 争取到锁后，在恢复 consumersynchronized(this) &#123; consumer.resume();&#125; 死锁场景二：先后顺序没有控制好123456789101112131415161718192021Object baozi = null;Thread consumer = new Thread(() -&gt; &#123; if (baozi == null) &#123; System.out.println(\"来晚了，卖光了\"); Thread.sleep(5000L); Thread.currentThread().suspend(); &#125; System.out.println(\"买到包子，回家\");&#125;);// 包子制作中Thread.sleep(3000L);baozi = new Object();System.out.println(\"新一笼的包子做好啦\");consumer.resume();consumer.join(); 4.2、wait/notify 机制123456synchronized(LOCK) &#123; Object.wait(); // wait会释放LOCK对象锁 &#125;synchronized(LOCK) &#123; Object.notify(); &#125; 这些方法只能由同一对象锁的持有者线程调用，也就是写在同步代码块里边，否则会抛出 IllegalMonitorStateException 异常。 wait 方法导致当前线程等待，加入该对象的等待集合中，并且放弃当前持有的对象锁。notify/notifyAll 方法唤醒一个或所有正在等待这个对象锁的线程。 注意：虽然会 wait 自动解锁，但是对顺序有要求，如果在 notify 被调用之后，才开始 wait 方法的调用，线程会永远处于 WAITING 状态。 4.3、park/unpark 机制12LockSupport.park();LockSupport.unpark(); 线程调用 park 则等待 “许可”，unpark 方法为指定线程提供 “许可(permit)”。 不要求 park/unpark 的调用顺序。 多次调用 unpark 后，再调用 park，线程会直接运行。但不会叠加，也就是说，连续多次调用 park 方法，第一次会拿到 “许可” 直接运行，后续调用会进入等待。 LockSupport 不会释放持有的对象锁，所以在同步代码块中，会出现死锁的现象。 死锁场景：123456789synchronized(LOCK) &#123; LockSupport.park();&#125;//...synchronized(LOCK) &#123; LockSuport.unpark();&#125; 伪唤醒警告！之前代码中用 if 语句来判断是否进入等待状态，是错误的！官方建议，应该在循环中检查等待条件，原因是处于等待状态的线程可能会收到错误报警和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。 伪唤醒是指线程并非因为 notify、notifyAll、unpark 等 api 调用唤醒，是更底层原因导致的。","categories":[{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/categories/thread/"}],"tags":[{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"},{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/tags/thread/"}]},{"title":"boy-learning-thread | 1.1.3 内存屏障和CPU缓存","slug":"java/thread/1.1.3 内存屏障和CPU缓存","date":"2019-10-12T16:00:00.000Z","updated":"2019-10-22T17:15:27.231Z","comments":true,"path":"2019/10/13/java/thread/1.1.3 内存屏障和CPU缓存/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/13/java/thread/1.1.3 内存屏障和CPU缓存/","excerpt":"","text":"相关源码：boy-learning-thread个人博客：http://bruce.bugmakers.club内容来自《网易微专业 - 高性能编程章节》 内存屏障和CPU缓存CPU 性能优化手段 - 缓存为了提高程序运行的性能，现代 CPU 在很多方面对程序进行了优化。 例如：CPU高速缓存。尽可能的避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。 CPU 多级缓存L1 Cache 一级缓存：CPU 第一层高速缓存，分为数据缓存和指令缓存。一般服务器 CPU 的 L1 缓存的容量通常在 32~4096KB。 L2 由于 L1 级高速缓存容量的限制，为了再次提高 CPU 的运算速度，在 CPU 外部放置一高速存储器，即二级缓存。 L3 现在的都是内置的。而它的实际作用即是，L3 缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。具有较大 L3 缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。一般是多核共享一个 L3 缓存！ cpu 在读取数据时，现在L1中寻找，再从L2中寻找，再从L3中寻找，然后是内存，再后是外存储器。 缓存同步协议多 CPU 读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存以哪个 CPU 为准？ 在这种高速缓存回写的场景下，有一个缓存一致性协议多数 CPU 厂商对他进行了实现。 MESI 协议，他规定每条缓存有个状态位，同时定义了下面四个状态： 修改态（Modified）——此 cache 行已被修改过（脏行），内容已不同于主存，为此 cache 专有； 专有态（Exclusive）——此 cache 行内容同于主存，但不出现与其他 cache 中； 共享态（Shared）——此 cache 行同于主存，但也出现于其他 cache 中； 无效态（Invalid）——此 cache 行内容无效（空行）。 多处理器时，单个 CPU 对缓存中的数据进行了改动，需要通知给其他 CPU。也就是意味着，CPU 处理要控制自己的读写操作，还要监听其他 CPU 发出的通知，从而保证最终一致。 CPU 性能优化手段 - 运行时指令重排指令重排场景：当 CPU 写缓存时，发现缓存区块正在被其他 CPU 占用，为了提高 CPU 处理性能，可能将后面的读缓存命令优先执行。 并非随便重排，需要遵守 as-if-serial 语义。 as-if-serial 语义指的是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说，编译器和处理器不会对存在数据依赖关系的操作做重排序。 两个问题1、CPU 高速缓存下，有一个问题： 缓存中的数据与主内存的数据并不是实时同步的，各 CPU （或 CPU 核心）间缓存的数据也不是实时同步。 在同一个时间点，各 CPU 所看到同一内存地址的数据的值可能是不一致的。 2、CPU 执行指令重排序优化下，有一个问题： 虽然遵守了 as-if-serial 语义，但仅在单 CPU 自己执行的情况下能保证结果正确。 多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。 处理方式 —— 内存屏障处理器提供了两个内存屏障指令（Memory Barrier）用于解决上述两个问题。 写内存屏障（Store Memory Barrier） 在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。 强制写入主内存，这种显示调用，CPU 就不会因为性能问题考虑而去对指令重排。 读内存屏障（Load Memory Barrier） 在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存中加载数据。 强制读取主内存内容，让 CPU 缓存与主内存保持一致，避免了缓存导致的一致性问题。 小结本章节内容主要是对后续 JVM 线程安全问题做的铺垫。 同时，也看到了现代 CPU 不断演进，在程序运行优化中做出的努力。 不同 CPU 厂商所付出的人力物力成本，最终体现在不同 CPU 性能差距上。","categories":[{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/categories/thread/"}],"tags":[{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"},{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/tags/thread/"}]},{"title":"boy-learning-thread | 1.1.2 线程终止","slug":"java/thread/1.1.2 线程终止","date":"2019-10-11T16:00:00.000Z","updated":"2019-10-22T17:13:52.060Z","comments":true,"path":"2019/10/12/java/thread/1.1.2 线程终止/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/12/java/thread/1.1.2 线程终止/","excerpt":"","text":"相关源码：boy-learning-thread个人博客：http://bruce.bugmakers.club内容来自《网易微专业 - 高性能编程章节》 线程终止不正确的线程终止 - stop() 方法stop: 终止线程，并且清除监视器锁的信息，但是可能导致线程安全问题，JDK不建议使用 destroy：JDK未实现该方法 api 示例12345678public class Demo &#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; System.out.print(\"hello world\"); &#125;); thread.stop(); &#125;&#125; 正确的线程终止1、正确的线程终止 - interrupt() 方法如果目标线程在调用 Object class 的 wait()、wait(long) 或者 wait(long, int)方法、join()、join(long, int) 或 sleep(long, int) 方法时被阻塞，那么 interrupt 会生效，该线程的中断状态将被清除，抛出 InterruptedExecption 异常。 如果目标线程是被 I/O 或者 NIO 中的 Channel 阻塞，同样，I/O 操作会被中断或者返回特殊异常值。达到终止线程的目的。 如果以上条件都不满足，则会设置此线程的中断状态。 api 示例12345678public class Demo &#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; System.out.print(\"hello world\"); &#125;); thread.interrupt(); &#125;&#125; 2、正确的线程终止 - 标志位代码逻辑中，增加一个判断，用来控制线程执行的终止。 为了避免线程可见性问题，一般用 volatile 修饰标志位成员变量，例如：123456789101112131415161718192021222324public class Demo extends Thread &#123; public volatile static boolean flag = true; public static void main(String [] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; try&#123; while(flag) &#123; System.out.println(\"running...\"); Thread.sleep(1000L); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); // 3秒后，将标志位修改为false，代表不在继续运行 Thread.sleep(3000L); flag = false; System.out.println(\"stop running\"); &#125;&#125;","categories":[{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/categories/thread/"}],"tags":[{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"},{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/tags/thread/"}]},{"title":"boy-learning-thread | 1.1.1 线程状态","slug":"java/thread/1.1.1 线程状态","date":"2019-10-10T16:00:00.000Z","updated":"2019-10-22T17:13:29.938Z","comments":true,"path":"2019/10/11/java/thread/1.1.1 线程状态/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/11/java/thread/1.1.1 线程状态/","excerpt":"","text":"相关源码：boy-learning-thread个人博客：http://bruce.bugmakers.club内容来自《网易微专业 - 高性能编程章节》 线程状态 New：尚未启动的线程的线程状态 12345678public class Demo&#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; log.info(\"hello world\"); &#125;); log.info(\"thread's NEW, let's check it: &#123;&#125;\", thread.getState().toString()); &#125;&#125; Runnable：可运行线程的线程状态，等待CPU调度 123456789public class Demo&#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; log.info(\"hello world\"); &#125;); thread.start(); log.info(\"thread's RUNNABLE, let's check it: &#123;&#125;\", thread.getState().toString()); &#125;&#125; Blocked：线程阻塞等待监视器锁定的线程状态，处于synchronized同步代码块或方法中被阻塞 12345678910111213public class Demo&#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; synchronized (Demo.class) &#123; log.info(\"hello world\"); &#125; &#125;); synchronized (Demo.class) &#123; thread.start(); log.info(\"thread's BLOCKED, let's check it: &#123;&#125;\", thread.getState().toString()); &#125; &#125;&#125; Waiting：等待线程的线程状态。下列不带超时的方式：Object.wait、Thread.join、LockSupport.park 1234567891011121314151617public class Demo&#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; synchronized (Demo.class) &#123; Demo.class.wait(); log.infoln(\"hello world\"); &#125; &#125;); thread.start(); Thread.sleep(200L); synchronized (Demo.class) &#123; log.info(\"thread's WAITING, let's check it: &#123;&#125;\", thread.getState().toString()); Demo.class.notify(); &#125; &#125;&#125; TimedWaiting：具有指定等待时间的等待线程的线程状态。下列带超时的方式：Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil 12345678910111213141516public class Demo&#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; try&#123; // 等待10秒 Thread.sleep(10000L); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; log.infoln(\"hello world\"); &#125;); thread.start(); Thread.sleep(2000L); log.info(\"thread's TIMED_WAITING, let's check it: &#123;&#125;\", thread.getState().toString()); &#125;&#125; Terminated：终止线程的线程状态。线程正常完成执行或者出现异常。 12345678910public class Demo&#123; public static void main(String [] args) &#123; Thread thread = new Thread(() -&gt; &#123; log.info(\"hello world\"); &#125;); thread.start(); Thread.sleep(1000L); log.info(\"thread's TERMINATED, let's check it: &#123;&#125;\", thread.getState().toString()); &#125;&#125;","categories":[{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/categories/thread/"}],"tags":[{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"},{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/tags/thread/"}]},{"title":"boy-learning-thread | 1.1.0 JVM 运行时数据区","slug":"java/thread/1.1.0 JVM运行时数据区","date":"2019-10-09T16:00:00.000Z","updated":"2019-10-18T15:34:04.135Z","comments":true,"path":"2019/10/10/java/thread/1.1.0 JVM运行时数据区/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/10/java/thread/1.1.0 JVM运行时数据区/","excerpt":"","text":"相关源码：boy-learning-thread个人博客：http://bruce.bugmakers.club内容来自《网易微专业 - 高性能编程章节》 JVM 运行时数据区 1、线程共享部分所有线程都可以访问这块内存数据，随虚拟机或者GC而创建或销毁 1.1、方法区jvm用来存储类、常量、静态变量、编译后的代码等数据。 虚拟机规范中这是一个逻辑区划，不同的虚拟机有不同的实现。 如：oracle的HotSpot在java7中方法区放在永久代，java8放在元数据空间，并且通过GC机制对这个区域进行管理。 1.2、堆内存JVM启动时创建，存放对象的实例。 垃圾回收器主要管理堆内存。 如果堆内存满了，就会出现OutOfMemoryError。 2、线程独享部分每个线程都会有他独立的空间，随线程生命周期而创建或销毁 2.1、虚拟机栈每个线程都在这个空间有一个私有的空间，为虚拟机执行java方法而准备的。 线程栈由多个栈帧（Stack Frame）组成。 一个线程会执行一个或多个方法，一个方法对应一个栈帧。 栈帧内容：局部变量表、操作数栈、动态链接、方法返回地址、附加信息等。 栈内存默认最大是1M，超出则抛出 StackOverflowError 2.2、本地方法栈与虚拟机栈类似，为虚拟机使用Native本地方法而准备的。 不同的虚拟机厂商有不同的实现，HotSpot虚拟机中虚拟机栈和本地方法栈的实现是一样的，同样超出大小以后会抛出 StackOverflowError 2.3、程序计数器记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行Native方法，则计数器值为空。 每个线程都在这个空间有一个私有的空间，战勇内存空间很少。 cpu同一时间，只会执行一条线程中的指令。jvm多线程会轮流切换并分配cpu执行时间的方式。在线程切换后，需要通过程序计数器来恢复正确的执行位置。","categories":[{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/categories/thread/"}],"tags":[{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"},{"name":"thread","slug":"thread","permalink":"http://bruce.bugmakers.club/tags/thread/"}]},{"title":"boy-learning-netty | 10 keepalive 与 idle 监测","slug":"java/netty/10 keepalive与idle监测","date":"2019-10-09T16:00:00.000Z","updated":"2019-10-18T15:27:20.708Z","comments":true,"path":"2019/10/10/java/netty/10 keepalive与idle监测/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/10/java/netty/10 keepalive与idle监测/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 keepalive 与 idle 监测 为什么需要 keepalive？ 怎么设计 keepalive？以 TCP keepalive 为例 为什么还需要应用层 keepalive？ Idle 监测是什么？ 如何在 Netty 中开启 TCP keepalive 和 Idle 监测 为什么需要 keepalive？生活场景 假设你开了一个饭店，别人打电话来订餐，电话通了后，客户说了一堆订餐需求，说着说着就，对方就不讲话了（可能忘记挂机/出去办事/线路故障等）。 这个时候你会一直握着电话等么？ 不会 如果不会，那你一般怎么去做？ 会确认一句“你还在么？”，如果对方没有回复，那就挂机。这套机制即 “keepalive”。 类比服务器应用 订餐电话场景 服务器应用 电话线路 数据连接 （TCP连接） 交谈的话语 数据 通话双方 数据发送方和接收方 对比场景 订餐电话场景 应用服务器 需要 keepalive 的场景 对方临时着急离开 对端异常“崩溃” 需要 keepalive 的场景 对方在，但是很忙，不知道什么时候忙完 对端在，但是处理不过来 需要 keepalive 的场景 电话线路故障 对端在，但是不可达 不做 keepalive 的后果 线路占用，耽误其他人订餐 连接已坏，但是还浪费资源维持，下次用会直接报错 怎么设计 keepalive？以 TCP keepalive 为例TCP keepalive 核心参数1234# sysctl -a | grep tcp_keepalivenet.ipv4.tcp_keepalive_time=7200 # 问题出现概率小 -&gt; 没有必要频繁net.ipv4.tcp_keepalive_intvl=75net.ipv4.tcp_keepalive_probes=9 # 判断需“谨慎” -&gt; 不能武断 当启动（默认关闭） keepalive 时，TCP 在连接没有数据通过的 7200 秒后发送 keepalive 消息，当探测没有确认时，按 75 秒的重试频率重发，一直发 9 个探测包都没有确认，就认定连接失败。 所以总耗时一般为：2 小时 11 分钟（7200 秒 + 75 秒 * 9次） 为什么还需要应用层 keepalive？ 协议分层，各层关注点不同： 传输层关注是否“通”，应用层关注是否可服务。类比前面的电话订餐例子，电话能通，不代表有人接；服务器连接在，但是不一定可以服务（如服务不过来等）。 TCP 层的 keepalive 默认关闭，且经过路由等中转设备 keepalive 包可能会被丢弃。 TCP 层的 keepalive 时间太长，默认 &gt; 2 小时，虽然可以改，但属于系统参数，改动影响所有应用。 提示： HTTP 属于应用层协议，但是常常听到名词“HTTP Keep-Alive”指的是对长连接和短连接的选择： Connection：Keep-Alive 长连接（HTTP/1.1 默认长连接，不需要带这个 header） Connection：Close 短连接 Idle 监测是什么？重现生活场景 假设你开了一个饭店，别人打电话来订餐，电话通了后，客户说了一堆订餐需求，说着说着就，对方就不讲话了（可能忘记挂机/出去办事/线路故障等）。 这个时候你会一直握着电话等么？ 不会 一般你会稍微等待一定的时间，在这个时间内看看对方还会不会说话（Idle检测），如果还不说，认定对方存在问题（Idle），于是开始发问“你还在么？”（keepalive），或者问都不问干脆直接挂机。（关闭连接） Idle检测 Idle 监测，只是负责诊断，诊断后，做出不同的行为，决定 Idle 检测的最终用途： 发送 keepalive：一般用来配合 keepalive，减少 keepalive 消息。 Keepalive 设计演进： V1 定时 keepalive 消息 -&gt; V2 空闲监控 + 判定为 Idle 时才发 keepalive V1：keepalive 消息与服务器正常信息交换完全不关联，定时就发送； V2：有其他数据传输的时候，不发送 keepalive，无数据传输超过一定时间，判定为 Idle，再发 keepalive。 直接关闭连接： 快速释放损坏的、恶意的、很久不用的连接，让系统时刻保持最好的状态。 简单粗暴，客户端可能需要重连。 实际应用中：结合起来用。按需 keepalive，保证不会空闲，如果空闲，关闭连接。 如何在 Netty 中开启 TCP keepalive 和 Idle 监测开启不同的 Idle Check： 1ch.pipeline().addLast(\"idleCheckHandler\", new IdleStateHandler(0, 20, 0, TimeUnit.Seconds));","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 09 Netty 对常用编解码的支持","slug":"java/netty/09 Netty 对常用编解码的支持","date":"2019-10-08T16:00:00.000Z","updated":"2019-10-18T15:27:20.699Z","comments":true,"path":"2019/10/09/java/netty/09 Netty 对常用编解码的支持/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/09/java/netty/09 Netty 对常用编解码的支持/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 Netty 对常用编解码的支持 为什么需要 “二次” 解码 常用的 “二次” 编解码方式 选择编解码方式的要点 Protobuf 简介与使用 源码解读：Netty 对常用编解码的支持 为什么需要 “二次” 解码假设我们把解决粘包、半包问题的常见三种解码器叫一次解码器，那么，我们在项目中，除了可选的压缩解压缩之外，还需要一层解码，因为一次解码的结果是字节，需要和项目中所使用的的对象做转化，方便使用，这层解码器可以称为“二次解码器”，相应的，对应的编码器是为了将 Java 对象转化为字节流方便存储或传输。 一次解码器的结果是字节，二次解码器的结果是对象 一次解码器：ByteToMessageDecoder io.netty.buffer.ByteBuf（原始数据流） -&gt; io.netty.buffer.ByteBuf （用户数据流） 二次解码器：MessageToMessageDecoder io.netty.buffer.ByteBuf （用户数据） -&gt; Java Object 思考：是不是可以一步到位？合并一次解码（解决粘包、半包）和二次解码（解决可操作性问题） 可以，但是不建议 没有分层，不够清晰 耦合性高，不容易置换方案 常用的 “二次” 编解码方式 Java 序列化：只有 java 能用，比较占空间 Marshaling：jboss XML JSON MessagePack Protobuf：性能好，可读性差 其他 选择编解码方式的要点 空间：编码后占用空间大小，需要比较不同原始数据大小情况 时间：编码后占用时间大小，需要比较不同原始数据大小情况 是否追求可读性 对多语言的支持 Protobuf 简介与使用简介 Protobuf 是一个灵活的、高效的用于序列化数据的协议。 相比较 XML 和 JSON 格式，Protobuf 更小、更快、更便捷。 Protobuf 是跨语言的，并且自带了一个编译器（protoc），只需要用它进行编译，可以自动生成Java、python、C++等代码，不需要在写其他代码。 使用 下载对应操作系统的 protoc 编写 .proto 文件 生成代码 123protoc.exe --java_out=. demo.protoprotoc.exe --python_out=. demo.protoprotoc.exe --cpp_out=. demo.proto 源码解读：Netty 对常用编解码的支持 netty 原代码的 netty-codec 模块下可以看到 netty 支持的编解码方式 netty 使用 Protobuf 编解码示例 123456789101112131415// 参考源代码：WorldClockClientInitializer.javapublic void initChannel(SocketChannel ch) &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc(), WorldClockClient.HOST, WorldClockClient.PORT)); &#125; // varint 为可变长度 p.addLast(new ProtobufVarint32FrameDecoder()); p.addLast(new ProtobufDecoder(WorldClockProtocol.LocalTimes.getDefaultInstance())); p.addLast(new ProtobufVarint32LengthFieldPrepender()); p.addLast(new ProtobufEncoder()); p.addLast(new WorldClockClientHandler());&#125;","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 08 Netty 是如何处理 TCP 粘包、半包等问题的","slug":"java/netty/08 Netty 是如何处理 TCP 粘包、半包等问题的","date":"2019-10-07T16:00:00.000Z","updated":"2019-10-18T15:27:20.703Z","comments":true,"path":"2019/10/08/java/netty/08 Netty 是如何处理 TCP 粘包、半包等问题的/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/08/java/netty/08 Netty 是如何处理 TCP 粘包、半包等问题的/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 Netty 是如何处理 TCP 粘包、半包等问题的 什么是粘包和半包 为什么 TCP 应用中会出现粘包和半包现象 解决粘包和半包问题的集中常用方法 Netty 对三种常用封帧方式的支持 解读 Netty 处理粘包、半包的源码 什么是粘包和半包粘包 客户端多次发送 ABC， 服务端接收到 ABC? 如：ABCA, ABCAB, ABCABC 主要原因： 发送方每次写入数据 &lt; 套接字缓冲区大小 接收方读取套接字缓冲区数据不及时 半包 客户端多次发送 ABC， 服务端接收到 A? B? 如：AB, BC, CA 主要原因： 发送方每次写入数据 &gt; 套接字缓冲区大小 发送的数据大于协议的 MTU(Maximum Transmission Unit, 最大传输单元)，必须拆包 换个角度看粘包和半包 收发 一个发送可能被多次接收，多个发送可能被一次接收 传输 一个发送可能占用多个传输包，多个发送可能公用一个传输包 为什么 TCP 应用中会出现粘包和半包现象根本原因： TCP 是流式协议，消息无边界。 提醒：UDP 像邮寄的包裹，虽然一次运输多个，但每个包裹都有“界限”，一个一个签收，所以无粘包、半包问题。 解决粘包和半包问题的集中常用方法根本手段：找出消息的边界。 方式\\比较 寻找消息边界的方式 优点 缺点 推荐度 TCP 连接改成短连接，一个请求一个短连接 建立连接到释放连接之间的信息即为传输信息 简单 效率低下 不推荐 封装成帧 Framing - 固定长度 满足固定长度即可 简单 浪费空间 不推荐 封装成帧 Framing - 分隔符 分隔符之间 空间不浪费，也比较简单 内容本身出现分隔符时需要转义，所以需要扫描内容，耗费资源 一般 封装成帧 Framing - 固定长度字段储存内容长度信息 先解析固定长度字段，再读取后续内容 精确定位用户数据，也不用转义 长度理论上有限制，需提前预知可能的最大长度从而定义长度占用字节数 推荐 封装成帧 Framing - 其他方式 每种都不同，如JSON可以看{}是否应已经成对 衡量实际场景 衡量实际场景 很多是对现有协议的支持 Netty 对三种常用封帧方式的支持 方式\\支持 解码 编码 封装成帧 Framing - 固定长度 FixedLengthFrameDecoder 简单 封装成帧 Framing - 分隔符 DelimiterBasedFrameDecoder 简单 封装成帧 Framing - 固定长度字段储存内容长度信息 LengthFieldBasedFrameDecoder LengthFieldPrepender 解读 Netty 处理粘包、半包的源码 解码核心工作流程 ByteToMessageDecoder 入手 解码中两种数据累计器(Cumulator)的区别 第一种 MERGE_CUMULATOR（默认）：内存复制 第二种 COMPOSITE_CUMULATOR：逻辑视图 三种解码器的常用额外控制参数有哪些 长度 分隔符（支持一个或多个） 固定长度字段等","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 07 Netty 如何支持三种 Reactor","slug":"java/netty/07 Netty 如何支持三种 Reactor","date":"2019-10-06T16:00:00.000Z","updated":"2019-10-18T15:27:20.682Z","comments":true,"path":"2019/10/07/java/netty/07 Netty 如何支持三种 Reactor/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/07/java/netty/07 Netty 如何支持三种 Reactor/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 Netty 如何支持三种 Reactor 什么是 Reactor 及三种版本 如何在 Netty 中使用 Reactor 模式 解析 Netty 对 Reactor 模式支持的常见疑问 什么是 Reactor 及三种版本生活场景：返点规模变化 一个人包揽所有：迎宾、点菜、做饭、上菜、送客等； 多招几个伙计：大家一起做上面的事 进一步分工：搞一个或多个人专门做迎宾 生活场景类比 饭店伙计：线程 迎宾工作：接入连接 点菜：请求 做菜：业务处理 上菜： 响应 送客： 断连 生活场景 Reactor 模式 一个人包揽所有：迎宾、点菜、做饭、上菜、送客 Reactor 单线程模式 多招几个伙计：大家一起做上面的事 Reactor 多线程模式 进一步分工：搞一个或多个专门做迎宾 主从 Reactor 多线程模式 Reactor 与三种 I/O 模式对应关系 I/O 模式 Reactor 版本 BIO Thread-Per-Connection NIO Reactor AIO Proactor Reactor 是一种开发模式，模式的核心流程： 注册感兴趣的事件 -&gt; 扫描是否有感兴趣的事件发生 -&gt; 事件发生后做出相应的处理。 client/server SocketChannel/ServerSocketChannel OP_ACCEPT OP_CONNECT OP_WRITE OP_READ client SocketChannel - Y Y Y server ServerSocketChannel Y - - - server SocketChannel - - Y Y 如何在 Netty 中使用 Reactor 模式Reactor 单线程模式 EventLoopGroup group = new NioEventLoopGroup(1); ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(group); 非主从 Reactor 多线程模式 EventLoopGroup group = new NioEventLoopGroup(); ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(group); 主从 Reactor 多线程模式 EventLoopGroup bossGroup = new NioEventLoopGroup(); // 这里没有 1，系统会根据cpu核数自动计算合适的数字 EventLoopGroup workerGroup = new NioEventLoopGroup(); ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup, workerGroup); 解析 Netty 对 Reactor 模式支持的常见疑问 Netty 如何支持主从 Reactor 模式的？ 源码上理解 为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里边的一个？ 源码上理解 Netty 给 Channel 分配 NIO event loop 的规则是什么？ 源码上理解 通用模式的 NIO 实现多路复用器是怎么跨平台的？ 源码上理解 SeletorProvider.provider() loadProviderAsService() DefaultProviderSelector.create(); // 这里就是不用的平台的实现了","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 06 Netty 怎么切换三种 I/O 模式","slug":"java/netty/06 Netty 怎么切换三种 IO模式","date":"2019-10-05T16:00:00.000Z","updated":"2019-10-18T15:27:20.695Z","comments":true,"path":"2019/10/06/java/netty/06 Netty 怎么切换三种 IO模式/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/06/java/netty/06 Netty 怎么切换三种 IO模式/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 Netty 怎么切换三种 I/O 模式 什么是经典的三种 I/O 模式 Netty 对三种 I/O 模式的支持 为什么 Netty 仅支持 NIO 了？ 为什么 Netty 有多种 NIO 实现？ NIO 一定优于 BIO 吗？ 源码解读 Netty 怎么切换 I/O 模式 什么是经典的三种 I/O 模式场景 当我们去饭店吃饭时： 食堂排队打饭模式：排队在窗口，打好才走 点单、等待被叫模式：等待被叫，好了自己去端 包厢模式：点单后菜直接被端上桌 类比 饭店 -&gt; 服务器 饭菜 -&gt; 数据 饭菜好了 -&gt; 数据就绪 端菜/送菜 -&gt; 数据读取 场景 I/O 模式 JDK 排队打饭模式 BIO（阻塞I/O） jdk1.4之前 点单、等待被叫模式 NIO（非阻塞I/O） jdk1.4 (2002年，java.nio包) 包厢模式 AIO（异步I/O） jdk1.7 (2011年) 阻塞与非阻塞 菜没好，要不要死等 -&gt; 数据就绪前要不要等待？ 阻塞：没有数据传过来时，读会阻塞知道有数据；缓冲区满时，写操作也会阻塞。非阻塞遇到这些情况都是直接返回。 同步与异步 菜好了，谁端 -&gt; 数据就绪后，数据操作谁完成？ 数据就绪后，需要自己去读是同步，数据就绪直接读好再回调给程序是异步。 Netty 对三种 I/O 模式的支持 BIO 曾经支持，现已经不支持了 NIO 都支持，且有多种实现：通用的实现，linux上的实现，macOs上的实现 AIO 曾经支持，现已移除 为什么 Netty 仅支持 NIO 了？ 为什么不建议阻塞I/O (BIO 或 OIO)？ 连接数高的情况下，阻塞 -&gt; 耗资源、效率低 为什么删除已经做好的 AIO 支持？ Windows 实现成熟，但是windows系统很好用来做服务器 Linux 常用来做服务器，但是 AIO 实现不够成熟 Linux 下 AIO 相比较 NIO 性能提升不明显 为什么 Netty 有多种 NIO 实现？通用的 NIO 实现在 Linux 下也是使用 epoll，为什么自己单独实现？ 实现得更好！ Netty 暴露了更多的可控参数，例如： JDK 的 NIO 默认现实是水平触发 Netty 是边缘触发（默认）和水平触发可切换 Netty 实现的垃圾回收更少、性能更好 NIO 一定优于 BIO 吗？ BIO 实现的代码简单 特定场景：连接数少，并发度低，BIO 性能不输 NIO 源码解读 Netty 怎么切换 I/O 模式 怎么切换 修改 EventLoopGroup —— 开发模式 SocketChannel —— I/O 模式 原理是什么 泛型+反射+工厂 实现 I/O 模式的切换 为什么服务器开发并不需要切换客户端对应 Socket Reactor 模式，死循环监听处理事件","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 05 Netty 的现状与趋势","slug":"java/netty/05 Netty 的现状与趋势","date":"2019-10-04T16:00:00.000Z","updated":"2019-10-18T15:27:20.672Z","comments":true,"path":"2019/10/05/java/netty/05 Netty 的现状与趋势/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/05/java/netty/05 Netty 的现状与趋势/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 Netty 的现状与趋势社区现状 https://github.com/netty/netty Stars: 20000+ (Top 25 repository on java) 维护者 22 members (core: Trustin Lee and Norman Maurer) 分支 4.1 master （16年5月创建，hours/days ago） 支持 Android 4.0 （13年7月创建， 最有一次提交时2018年2月13号）线程模型优化、包结构、命名 最新版本 Netty 4.1.39.Final (2019/08) Netty 4.0.56.Final (2018/02) Netty 3.10.6.Final (2016/06) 应用现状* 截止 2019/09,30000+项目在使用 * 统计方法：在 github 上 pom.xml 中声明了 io.netty:netty-all * 为考虑情况：非开源软件和 Netty3.x 使用者 一些典型项目： 数据库：Cassandra 大数据处理：Spark、Hadoop 消息队列：RocketMQ 检索：ElasticSearch 框架：gRPC、Apache Dubbo、Spring5(Spring Web Flux) 分布式协调器：Zookeeper 工具类：async-http-client 其他参考：https://netty.io/wiki/adopters.html 趋势 更多流行协议的支持 跟紧 JDK 的更新步伐 更多易用、人性化的功能：黑白名单、流量整形 应用越来越多","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 04 Netty 的前尘往事","slug":"java/netty/04 Netty的前尘往事","date":"2019-10-03T16:00:00.000Z","updated":"2019-10-18T15:27:20.661Z","comments":true,"path":"2019/10/04/java/netty/04 Netty的前尘往事/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/04/java/netty/04 Netty的前尘往事/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 Netty 的前尘往事从归属组织上看发展 JBoss （4.0之前） Netty （4.0之后） 从版本演变上看发展 2004 年 6 月 Netty2 发布 声称 java 社区中第一个基于事件驱动的应用网络框架 2008 年 10 月 Netty3 发布 2013 年 7 月 Netty4 发布 2013 年 7 月发布 5.0.0.Alpha1 2015 年 11 月废弃 5.0.0 题外话1：为什么废弃 5.0.0 复杂 没有证明明显的性能优势 维护不过来 所有的开源软件不要用 Alpha 版本，即使该版本是未来的发展趋势也不要用，如果是趋势，会在后续正式版中更新出来 题外话2：与 Apache Mina 的关系？ 同一作者开发，都处于维护阶段（当前：Mina 2.1.3：:219/06；Netty 4.1.39.Final：2019/08） 2004 年 6 月 Netty2 发布 2005 年 5 月 Mina 发布 Alex 为 Apache Directory 开发网络框架，但是觉得不好用，看到 Netty2 后，找到作者邀请合作开发，结合两种框架，随后有了 MINA。","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 03 为什么孤注一掷：独选 Netty","slug":"java/netty/03 为什么选择Netty","date":"2019-10-02T16:00:00.000Z","updated":"2019-10-18T15:27:20.651Z","comments":true,"path":"2019/10/03/java/netty/03 为什么选择Netty/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/03/java/netty/03 为什么选择Netty/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 为什么孤注一掷：独选 Netty其他常见网络编程框架 Apache Mina Sun Grizzly Apple SwiftNIO、ACE 等 Cindy 等 Tomcat、Jetty 为什么不选 Mina同一作者，推荐 Netty。 Mina 有的问题在 Netty 修复 为什么不选 Sun Grizzly用的少、文档少、更新少 为什么不选 Apple SwiftNIO、ACE等其他语言，不考虑 为什么不选择 Cindy 等生命周期不长 为什么不选择 Tomcat、Jetty还没有独立出来 Netty 这么牛，为什么Tomcat不选择它呢Tomcat是90年代出来的，Netty尚未出来","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 02 为什么舍近求远：不直接使用 JDK NIO","slug":"java/netty/02 不直接使用 JDK NIO","date":"2019-10-01T16:00:00.000Z","updated":"2019-10-18T15:27:20.689Z","comments":true,"path":"2019/10/02/java/netty/02 不直接使用 JDK NIO/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/02/java/netty/02 不直接使用 JDK NIO/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 为什么舍近求远：不直接使用 JDK NIO Netty 做的更多 Netty 做的更好 自己在 NIO 上研发难度非常大 Netty 做的更多 支持常用应用协议层(http/tcp/udp) 解决传输问题：粘包、半包现象(tcp 容易出现这两个问题，nio不会处理这些问题，netty会) 支持流量整形（流量控制、黑白名单） 完善的断连、Idle（空闲）等异常处理 Netty 做的更好1、规避JDK NIO bug 经典的 epoll bug：异常唤醒空转导致 CPU 100%jdk6 linux 2.4 _ jdk 不修复，netty 规避 IP_TOS 参数（IP 包的优先级和 QoS 选项）使用时抛出异常jdk12 解决，netty 规避 2、API 更友好更强大 JDK 的 NIO 一些 API 不够友好，功能薄弱，例如 ByteBuffer -&gt; Netty’s ByteBufByteBuffer: 内部实现是一个final的字节数组，不可以扩容，只有一个指针维护他的状态，在读写切换操作的时候需要一个额外的操作(sleep)ByteBuf: 有两个指针对应读写操作，可扩容 除了 NIO 外，也提供了其他一些增强：ThreadLocal -&gt; Netty’s FastThreadLocal 3、隔离变化、屏蔽细节 隔离 JDK NIO 的实现变化： nio -&gt; nio2(aio) -&gt; … 屏蔽 JDK NIO 的实现细节 自己直接使用 JDK NIO 实现的可能性？ 大概些多少行代码Netty Transport Package: source code lines 18584 可能面对的问题： 400 open， 4347 closed（2019/09 统计） “踏平” 多少 JDK NIO bug：5654 未来能维护多久？Netty 已经维护 15 年（from 2004 to 2019） 直接使用 NIO = 一个人在战斗","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"boy-learning-netty | 01 认识 Netty","slug":"java/netty/01 认识Netty","date":"2019-09-30T16:00:00.000Z","updated":"2019-10-18T15:27:20.636Z","comments":true,"path":"2019/10/01/java/netty/01 认识Netty/","link":"","permalink":"http://bruce.bugmakers.club/2019/10/01/java/netty/01 认识Netty/","excerpt":"","text":"相关源码：boy-learning-netty个人博客：http://bruce.bugmakers.club内容来自《极客时间 - Netty源码剖析与实战》 认识 NettyNetty 由 Trustin Lee （韩国，Line 公司–类似微信）2004 年开发。 官网：https://netty.io源码：https://github.com/netty/netty 本质：网络应用程序框架 实现：异步、事件驱动 特性：高性能、可维护、快速开发 用途：开发服务器和客户端","categories":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/categories/netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"http://bruce.bugmakers.club/tags/netty/"},{"name":"boy-learning","slug":"boy-learning","permalink":"http://bruce.bugmakers.club/tags/boy-learning/"}]},{"title":"docker/4-docker-temp","slug":"docker/4-docker-temp","date":"2019-05-19T16:33:46.526Z","updated":"2019-05-19T16:33:46.536Z","comments":true,"path":"2019/05/20/docker/4-docker-temp/","link":"","permalink":"http://bruce.bugmakers.club/2019/05/20/docker/4-docker-temp/","excerpt":"","text":"1、Docker Hub 公有仓库在Docker Hub官网上注册账号 https://hub.docker.com 在自己的docker环境上登录公有仓库 12345# logindocker login# logoutdocker logout 从公有仓库上拉取镜像 123456789# search imagedocker search &lt;image&gt;docker search hello-world# pull imagedocker pull &lt;image&gt;docker pull hello-world 将本地镜像推送到公有仓库 123456789101112131415# list local imagesdocker images# create a test image for hello-world to push (bruceouyang as your username)docker tag &lt;image&gt;[:&lt;tag&gt;] &lt;username&gt;/&lt;image_name or image_id&gt;[:&lt;tag&gt;]docker tag hello-world bruceouyang/hello-world:latest# check imagesdocker images# push imagedocker push &lt;image&gt;:&lt;tag&gt;docker push bruceouyang/hello-world:latest 2、私有仓库docker-registry 是官方提供的工具，可以用于构建私有镜像仓库。 安装运行 docker-registry 1docker run --name registry -d -p 5000:5000 --restart=always -v /opt/data/registry:/var/lib/registry registry –name 取个名字 -d 后台运行 -p 端口映射 –restart 重启设置 -v 挂在目录 最后一个 registry 表示基于 registry 镜像启动一个 检查运行中的容器 1docker ps 可以看到刚运行的 registry 推送本地镜像到私有仓库 12345678910111213# list local imagesdocker images# create a test image for a big one to pushdocker tag &lt;image&gt; &lt;registry_server_addr&gt;/&lt;image&gt;[:&lt;tag&gt;]docker tag tomcat:latest 127.0.0.1:5000/tomcat:latest# check imagesdocker images# push imagepush 127.0.0.1:5000/tomcat:latest 检查私有仓库中的镜像 1234curl 127.0.0.1:5000/v2/_catalog# output&gt; &#123;&quot;repositories&quot;:[&quot;tomcat&quot;]&#125; 从私有仓库中拉取镜像 1234567# remove local imagedocker rmi -f &lt;image&gt;docker rmi -f 127.0.0.1:5000/tomcat# pull image from private registrydocker pull 127.0.0.1:5000/tomcat 私有仓库对内网提供服务 注意 直接将127.0.0.1修改为本机的 ip 地址是没有效果的。 Docker 默认不允许非 HTTPS 方式推送镜像。 对于使用 systemd 的系统，可以在 /etc/docker/daemon.json 中写入如下内容（不存在则创建） 123456789&#123; &quot;registry-mirror&quot;: [ &quot;http://hub-mirror.c.163.com&quot;, &quot;https://registry.docker-cn.com&quot; ], &quot;insecure-registries&quot;:[ &quot;192.168.1.6: 5000&quot; ]&#125; 192.168.1.6 是我本地的 ip 地址，请修改为你自己的本地 ip","categories":[],"tags":[]},{"title":"docker | Docker 公有仓库和私有仓库","slug":"docker/3-docker-registry","date":"2019-05-06T00:12:00.000Z","updated":"2019-05-06T03:38:19.937Z","comments":true,"path":"2019/05/06/docker/3-docker-registry/","link":"","permalink":"http://bruce.bugmakers.club/2019/05/06/docker/3-docker-registry/","excerpt":"","text":"1、Docker Hub 公有仓库在Docker Hub官网上注册账号 https://hub.docker.com 在自己的docker环境上登录公有仓库 12345# logindocker login# logoutdocker logout 从公有仓库上拉取镜像 123456789# search imagedocker search &lt;image&gt;docker search hello-world# pull imagedocker pull &lt;image&gt;docker pull hello-world 将本地镜像推送到公有仓库 123456789101112131415# list local imagesdocker images# create a test image for hello-world to push (bruceouyang as your username)docker tag &lt;image&gt;[:&lt;tag&gt;] &lt;username&gt;/&lt;image_name or image_id&gt;[:&lt;tag&gt;]docker tag hello-world bruceouyang/hello-world:latest# check imagesdocker images# push imagedocker push &lt;image&gt;:&lt;tag&gt;docker push bruceouyang/hello-world:latest 2、私有仓库docker-registry 是官方提供的工具，可以用于构建私有镜像仓库。 安装运行 docker-registry 1docker run --name registry -d -p 5000:5000 --restart=always -v /opt/data/registry:/var/lib/registry registry –name 取个名字 -d 后台运行 -p 端口映射 –restart 重启设置 -v 挂在目录 最后一个 registry 表示基于 registry 镜像启动一个 检查运行中的容器 1docker ps 可以看到刚运行的 registry 推送本地镜像到私有仓库 12345678910111213# list local imagesdocker images# create a test image for a big one to pushdocker tag &lt;image&gt; &lt;registry_server_addr&gt;/&lt;image&gt;[:&lt;tag&gt;]docker tag tomcat:latest 127.0.0.1:5000/tomcat:latest# check imagesdocker images# push imagepush 127.0.0.1:5000/tomcat:latest 检查私有仓库中的镜像 1234curl 127.0.0.1:5000/v2/_catalog# output&gt; &#123;&quot;repositories&quot;:[&quot;tomcat&quot;]&#125; 从私有仓库中拉取镜像 1234567# remove local imagedocker rmi -f &lt;image&gt;docker rmi -f 127.0.0.1:5000/tomcat# pull image from private registrydocker pull 127.0.0.1:5000/tomcat 私有仓库对内网提供服务 注意 直接将127.0.0.1修改为本机的 ip 地址是没有效果的。 Docker 默认不允许非 HTTPS 方式推送镜像。 对于使用 systemd 的系统，可以在 /etc/docker/daemon.json 中写入如下内容（不存在则创建） 123456789&#123; &quot;registry-mirror&quot;: [ &quot;http://hub-mirror.c.163.com&quot;, &quot;https://registry.docker-cn.com&quot; ], &quot;insecure-registries&quot;:[ &quot;192.168.1.6: 5000&quot; ]&#125; 192.168.1.6 是我本地的 ip 地址，请修改为你自己的本地 ip","categories":[{"name":"docker","slug":"docker","permalink":"http://bruce.bugmakers.club/categories/docker/"}],"tags":[{"name":"公有仓库","slug":"公有仓库","permalink":"http://bruce.bugmakers.club/tags/公有仓库/"},{"name":"私有仓库","slug":"私有仓库","permalink":"http://bruce.bugmakers.club/tags/私有仓库/"}]},{"title":"docker | 构建私有镜像","slug":"docker/2-build-private-image","date":"2019-05-04T14:20:00.000Z","updated":"2019-05-04T14:20:57.331Z","comments":true,"path":"2019/05/04/docker/2-build-private-image/","link":"","permalink":"http://bruce.bugmakers.club/2019/05/04/docker/2-build-private-image/","excerpt":"","text":"一、使用 Dockerfile 定制镜像1、FROM 指定基础镜像 1FROM nginx 2、RUN 执行命令 1RUN echo &apos;&lt;h1&gt;hello docker&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html 3、构建镜像 12345# 构建docker build -t mynginx:1.0 .# 查看镜像docker images 4、运行镜像 1234567891011# 运行docker run --name mynginx -p 80:80 mynginx:1.0# 查看运行中的容器docker ps# 检查宿主机端口netstat -na | grep 80# 进入容器内部，可以检查 index.html 是否是我们预期的内容docker exec -it mynginx /bin/bash Dockerfile 指令详解 COPY 复制文件 123# COPY &lt;源路径&gt; ... &lt;目标路径&gt;# COPY [&lt;源路径&gt; ... &lt;目标路径&gt;]COPY package.json /usr/src/app/ COPY 指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置 &lt;源路径&gt;可以是多个，甚至可以是通配符，如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ ADD 更高级的复制文件 在 COPY 的基础上增加了一些功能，例如：&lt;源路径&gt;可以是一个 URL 。由于 COPY 的语义很明确，官方推荐尽可能的使用 COPY 。 在 COPY 和 ADD 指令选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，尽在需要自动解压缩的场合使用 ADD 。 CMD 容器启动命令 CMD 指令的格式和 RUN 相似，也是两种格式 shell 格式： CMD &lt;命令&gt; exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…] 参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程启动的命令。 ENTRYPOINT 入口点 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令了，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： 1&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; ENV 设置环境变量 格式有两种： ENV ENV = = 这个指令很简单，就是设置环境变量而已，无论是后面的其他指令，如 RUN ，还是运行时的应用，都可以直接使用这里定义的环境变量。 12ENV VERSION=1.0 DEBUG=on NAME=&quot;Happy Feet&quot;$VERSION # 使用环境变量 下列指令可以支持环境变量展开： 12345678910ADDCOPYENVEXPOSELABELUSERWORKDIRVOLUMESTOPSIGNALONBUILD ARG 构建参数 格式： ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 Dockerfile 中的 ARG 指令是定义参数名称，以及定义期默认值。该默认值可以在构建命令 docker build 中用 --build-arg &lt;参数名称&gt;=&lt;值&gt; 来覆盖。 VOLUME 定义匿名卷 格式为： VOLUME [“路径1”, “路径2”…] VOLUME &lt;路径&gt; 容器运行时应该尽量保持容器存储层不发生些操作，对于数据库类需要保持动态数据的应用，其数据库文件应该保持与卷(volume)中，我们可以实现指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。 比如： 1docker run -d -v mydata:/data xxxx 在这行命令中，就是用了 mydata 这个命令卷挂载到了 /data 这个位置，代替了 Dockerfile 中定义的匿名卷的挂载配置。 EXPOSE 声明端口 格式为： EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…] EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。 在 Dockerfile 中写入这样的声明有两个好处： 是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射； 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 WORKDIR 指定工作目录 格式为： WORKDIR &lt;工作目录路径&gt; 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如果该目录不存在，WORKDIR 会帮你建立目录。 之前提到的一些初学者常犯的错误是把 Dockfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： 12RUN cd /appRUN echo &quot;hello&quot; &gt; world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件。 原因 在 shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令 在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。 这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。 第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 USER 指定当前用户 格式： USER &lt;用户名&gt; USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN 、CMD 以及 ENTRYPOINT 这类命令的身份 当然，和 WORKDIR 一样，USER 只是帮助你切换到指定的用户而已，这个用户必须是实现建立好的，否则无法切换。 123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [&quot;redis-server&quot;] HEALTHCHECK 健康检查 格式： HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，可以屏蔽掉漆健康检查指令 HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。通过该指令指定一行命令，用这行命令来判断容器的主进程的服务状态是否正常，从而比较真实的反应容器实际状态。 一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在执行健康检查成功之后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 HEALTHCHECK 支持下列选项： –interval=&lt;间隔&gt;：两次健康检查的间隔，默认为30秒； –timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被石炜失败，默认30秒； –retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认3次。 为了帮助排查，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。 ONBUILD 为他人做嫁衣 格式： ONBUILD &lt;其他指令&gt; ONBUILD 是一个特殊的指令，它后面跟的是其他指令，比如 RUN , COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。 Dockerfile 中的其他指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。 二、其他制作镜像的方式1、docker save 和 docker load Docker 还提供了 docker save 和 docker load 命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐了，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。 例如： 保存 nginx 镜像 1docker save nginx | gzip &gt; nginx-latest.tar.gz 然后，我们将 nginx-latest.tar.gz 文件复制到另一个机器上，再加载镜像： 1docker load -i nginx-latest.tar.gz","categories":[{"name":"docker","slug":"docker","permalink":"http://bruce.bugmakers.club/categories/docker/"}],"tags":[{"name":"私有镜像","slug":"私有镜像","permalink":"http://bruce.bugmakers.club/tags/私有镜像/"},{"name":"构建镜像","slug":"构建镜像","permalink":"http://bruce.bugmakers.club/tags/构建镜像/"}]},{"title":"docker | 在 centos 上安装 docker","slug":"docker/1-install-docker-on-centos","date":"2019-04-25T03:50:00.000Z","updated":"2019-04-25T03:51:33.082Z","comments":true,"path":"2019/04/25/docker/1-install-docker-on-centos/","link":"","permalink":"http://bruce.bugmakers.club/2019/04/25/docker/1-install-docker-on-centos/","excerpt":"","text":"install docker on centos https://docs.docker.com/install/linux/docker-ce/centos/ 1 uninstall old versions12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2 install docker-ce using the repositoryinstall required packages 123sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 set up the stable repository 123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo A install the latest version of docker-ce 1sudo yum install docker-ce docker-ce-cli containerd.io B install a specific version of docker-ce list avaiable in your repo 1234567yum list docker-ce --showduplicates | sort -r# outputdocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable select your specific version &amp; install 1234sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io# example: sudo yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io &lt;VERSION_STRING&gt; 取第二列的第一个冒号和第一个横杠中间的字符串 3 start docker1sudo systemctl start docker 4 verify that docker-ce is installed correctly by running the hello-world image1sudo docker run hello-world ####","categories":[{"name":"docker","slug":"docker","permalink":"http://bruce.bugmakers.club/categories/docker/"}],"tags":[{"name":"docker 安装","slug":"docker-安装","permalink":"http://bruce.bugmakers.club/tags/docker-安装/"}]},{"title":"Spring | Transaction 事物","slug":"spring/transaction/Spring 事物基础","date":"2019-04-21T15:57:00.000Z","updated":"2019-04-21T16:23:02.989Z","comments":true,"path":"2019/04/21/spring/transaction/Spring 事物基础/","link":"","permalink":"http://bruce.bugmakers.club/2019/04/21/spring/transaction/Spring 事物基础/","excerpt":"","text":"Spring 事物抽象 一致的事物模型 JDBC/Hibernate/MyBatis DataSource/JTA 事物抽象的核心接口PlatformTransactionManager DataSrouceTransactionManager HibernateTransactionManager JtaTransactionManager 123void commit(TransactionStatus status) throws TransactionException;void rollback(TransactionStatus status) throws TransactionException;TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; 事物传播特性// todo 事物隔离级别// todo","categories":[{"name":"spring","slug":"spring","permalink":"http://bruce.bugmakers.club/categories/spring/"}],"tags":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://bruce.bugmakers.club/tags/Java-基础/"},{"name":"Spring Transaction","slug":"Spring-Transaction","permalink":"http://bruce.bugmakers.club/tags/Spring-Transaction/"}]},{"title":"开发工具 | Intellij IDEA神器居然还有这些小技巧","slug":"idea/Intellij IDEA神器居然还有这些小技巧","date":"2019-01-11T05:17:57.446Z","updated":"2019-01-11T05:17:57.447Z","comments":true,"path":"2019/01/11/idea/Intellij IDEA神器居然还有这些小技巧/","link":"","permalink":"http://bruce.bugmakers.club/2019/01/11/idea/Intellij IDEA神器居然还有这些小技巧/","excerpt":"","text":"","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://bruce.bugmakers.club/categories/开发工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://bruce.bugmakers.club/tags/idea/"}]},{"title":"awesome | 规则引擎 - QLExpress","slug":"awesome/QLExpress","date":"2018-12-22T09:03:00.000Z","updated":"2019-01-08T15:07:02.636Z","comments":true,"path":"2018/12/22/awesome/QLExpress/","link":"","permalink":"http://bruce.bugmakers.club/2018/12/22/awesome/QLExpress/","excerpt":"","text":"一、简介QlExpress脚本语言解析工具诞生于2010年，是玄难大师根据当时汇金的业务需要开始编写。 该项目是由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。 QlExpress经过40多个小版本的迭代，性能和功能更加趋于稳定，被更多的团队接受和认可，在双11洪流高峰、复杂规则业务配置平台等场景下也得到更好的实战考验。 开源地址：https://github.com/alibaba/QLExpress 二、使用1、 依赖和调用说明maven 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;QLExpress&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 简单示例12345678ExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();context.put(&quot;a&quot;,1);context.put(&quot;b&quot;,2);context.put(&quot;c&quot;,3);String express = &quot;a+b*c&quot;;Object r = runner.execute(express, context, null, true, false);System.out.println(r); 2、语法介绍2.1 操作符和 java 对象操作普通 Java 语法12345678910111213//支持 +,-,*,/,&lt;,&gt;,&lt;=,&gt;=,==,!=,&lt;&gt;【等同于!=】,%,mod【取模等同于%】,++,--,//in【类似sql】,like【sql语法】,&amp;&amp;,||,!,等操作符//支持for，break、continue、if then else 等标准的程序控制逻辑n=10;for(sum=0,i=0;i&lt;n;i++)&#123;sum=sum+i;&#125;return sum; //逻辑三元操作a=1;b=2;max = a&gt;b?a:b; Java 的对象操作12345678import com.ql.util.express.test.OrderQuery;//系统自动会import java.lang.*,import java.util.*;query = new OrderQuery();//创建class实例,会根据classLoader信息，自动补全类路径query.setCreateDate(new Date());//设置属性query.buyer = &quot;张三&quot;;//调用属性,默认会转化为setBuyer(&quot;张三&quot;)result = bizOrderDAO.query(query);//调用bean对象的方法System.out.println(result.getId());//静态方法 2.2 脚本中定义function12345678910function add(int a,int b)&#123; return a+b;&#125;;function sub(int a,int b)&#123; return a - b;&#125;;a=10;return add(a,4) + sub(a,9); 2.3 扩展操作符：Operator替换if then else 等关键字1234567runner.addOperatorWithAlias(&quot;如果&quot;, &quot;if&quot;,null);runner.addOperatorWithAlias(&quot;则&quot;, &quot;then&quot;,null);runner.addOperatorWithAlias(&quot;否则&quot;, &quot;else&quot;,null);exp = &quot;如果 (语文+数学+英语&gt;270) 则 &#123;return 1;&#125; 否则 &#123;return 0;&#125;&quot;;DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.execute(exp,context,null,false,false,null); 如何自定义Operator12345678910111213141516//定义一个继承自com.ql.util.express.Operator的操作符public class JoinOperator extends Operator&#123; public Object executeInner(Object[] list) throws Exception &#123; Object opdata1 = list[0]; Object opdata2 = list[1]; if(opdata1 instanceof java.util.List)&#123; ((java.util.List)opdata1).add(opdata2); return opdata1; &#125;else&#123; java.util.List result = new java.util.ArrayList(); result.add(opdata1); result.add(opdata2); return result; &#125; &#125;&#125; 如何使用Operator1234567891011121314151617181920212223//(1)addOperatorExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.addOperator(&quot;join&quot;,new JoinOperator());Object r = runner.execute(&quot;1 join 2 join 3&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3]//(2)replaceOperatorExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.replaceOperator(&quot;+&quot;,new JoinOperator());Object r = runner.execute(&quot;1 + 2 + 3&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3]//(3)addFunctionExpressRunner runner = new ExpressRunner();DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;();runner.addFunction(&quot;join&quot;,new JoinOperator());Object r = runner.execute(&quot;join(1,2,3)&quot;, context, null, false, false);System.out.println(r);//返回结果 [1, 2, 3] 2.4 绑定java类或者对象的methodaddFunctionOfClassMethod + addFunctionOfServiceMethod123456789101112131415161718192021222324252627public class BeanExample &#123; public static String upper(String abc) &#123; return abc.toUpperCase(); &#125; public boolean anyContains(String str, String searchStr) &#123; char[] s = str.toCharArray(); for (char c : s) &#123; if (searchStr.contains(c+&quot;&quot;)) &#123; return true; &#125; &#125; return false; &#125;&#125;runner.addFunctionOfClassMethod(&quot;取绝对值&quot;, Math.class.getName(), &quot;abs&quot;, new String[] &#123; &quot;double&quot; &#125;, null);runner.addFunctionOfClassMethod(&quot;转换为大写&quot;, BeanExample.class.getName(), &quot;upper&quot;, new String[] &#123; &quot;String&quot; &#125;, null);runner.addFunctionOfServiceMethod(&quot;打印&quot;, System.out, &quot;println&quot;,new String[] &#123; &quot;String&quot; &#125;, null);runner.addFunctionOfServiceMethod(&quot;contains&quot;, new BeanExample(), &quot;anyContains&quot;, new Class[] &#123; String.class, String.class &#125;, null);String exp = “取绝对值(-100);转换为大写(\\&quot;hello world\\&quot;);打印(\\&quot;你好吗？\\&quot;);contains(&quot;helloworld&quot;,\\&quot;aeiou\\&quot;)”;runner.execute(exp, context, null, false, false); 2.5 macro 宏定义123456789runner.addMacro(&quot;计算平均成绩&quot;, &quot;(语文+数学+英语)/3.0&quot;);runner.addMacro(&quot;是否优秀&quot;, &quot;计算平均成绩&gt;90&quot;);IExpressContext&lt;String, Object&gt; context =new DefaultContext&lt;String, Object&gt;();context.put(&quot;语文&quot;, 88);context.put(&quot;数学&quot;, 99);context.put(&quot;英语&quot;, 95);Object result = runner.execute(&quot;是否优秀&quot;, context, null, false, false);System.out.println(r);//返回结果true 2.6 编译脚本，查询外部需要定义的变量和函数 注意以下脚本int和没有int的区别12345678910111213String express = &quot;int 平均分 = (语文+数学+英语+综合考试.科目2)/4.0;return 平均分&quot;;ExpressRunner runner = new ExpressRunner(true,true);String[] names = runner.getOutVarNames(express);for(String s:names)&#123; System.out.println(&quot;var : &quot; + s);&#125;//输出结果：var : 数学var : 综合考试var : 英语var : 语文 2.7 关于不定参数的使用12345678910111213141516171819202122@Test public void testMethodReplace() throws Exception &#123; ExpressRunner runner = new ExpressRunner(); IExpressContext&lt;String,Object&gt; expressContext = new DefaultContext&lt;String,Object&gt;(); runner.addFunctionOfServiceMethod(&quot;getTemplate&quot;, this, &quot;getTemplate&quot;, new Class[]&#123;Object[].class&#125;, null); //(1)默认的不定参数可以使用数组来代替 Object r = runner.execute(&quot;getTemplate([11,&apos;22&apos;,33L,true])&quot;, expressContext, null,false, false); System.out.println(r); //(2)像java一样,支持函数动态参数调用,需要打开以下全局开关,否则以下调用会失败 DynamicParamsUtil.supportDynamicParams = true; r = runner.execute(&quot;getTemplate(11,&apos;22&apos;,33L,true)&quot;, expressContext, null,false, false); System.out.println(r); &#125; //等价于getTemplate(Object[] params) public Object getTemplate(Object... params) throws Exception&#123; String result = &quot;&quot;; for(Object obj:params)&#123; result = result+obj+&quot;,&quot;; &#125; return result; &#125; 2.8 关于集合的快捷写法1234567891011121314@Testpublic void testSet() throws Exception &#123; ExpressRunner runner = new ExpressRunner(false,false); DefaultContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;(); String express = &quot;abc = NewMap(1:1,2:2); return abc.get(1) + abc.get(2);&quot;; Object r = runner.execute(express, context, null, false, false); System.out.println(r); express = &quot;abc = NewList(1,2,3); return abc.get(1)+abc.get(2)&quot;; r = runner.execute(express, context, null, false, false); System.out.println(r); express = &quot;abc = [1,2,3]; return abc[1]+abc[2];&quot;; r = runner.execute(express, context, null, false, false); System.out.println(r);&#125; 2.9 集合的遍历其实类似java的语法，只是ql不支持for(obj:list){}的语法，只能通过下标访问12345678910//遍历map map = new HashMap(); map.put(&quot;a&quot;, &quot;a_value&quot;); map.put(&quot;b&quot;, &quot;b_value&quot;); keySet = map.keySet(); objArr = keySet.toArray(); for (i=0;i&lt;objArr.length;i++) &#123; key = objArr[i]; System.out.println(map.get(key)); &#125; 3、运行参数和API列表介绍QLExpressRunner如下图所示，从语法树分析、上下文、执行过程三个方面提供二次定制的功能扩展。 3.1 属性开关isPrecise1234/** * 是否需要高精度计算 */private boolean isPrecise = false; 高精度计算在会计财务中非常重要，java的float、double、int、long存在很多隐式转换，做四则运算和比较的时候其实存在非常多的安全隐患。 所以类似汇金的系统中，会有很多BigDecimal转换代码。而使用QLExpress，你只要关注数学公式本身 订单总价 = 单价 数量 + 首重价格 + （ 总重量 - 首重） 续重单价 ，然后设置这个属性即可，所有的中间运算过程都会保证不丢失精度。 isShortCircuit1234/** * 是否使用逻辑短路特性 */private boolean isShortCircuit = true; 在很多业务决策系统中，往往需要对布尔条件表达式进行分析输出，普通的java运算一般会通过逻辑短路来减少性能的消耗。例如规则公式： star&gt;10000 and shoptype in(‘tmall’,’juhuasuan’) and price between (100,900) 假设第一个条件 star&gt;10000 不满足就停止运算。但业务系统却还是希望把后面的逻辑都能够运算一遍，并且输出中间过程，保证更快更好的做出决策。 参照单元测试: ShortCircuitLogicTest.java isTrace1234/** * 是否输出所有的跟踪信息，同时还需要log级别是DEBUG级别 */private boolean isTrace = false; 这个主要是是否输出脚本的编译解析过程，一般对于业务系统来说关闭之后会提高性能。 3.2 调用入参123456789101112/** * 执行一段文本 * @param expressString 程序文本 * @param context 执行上下文，可以扩展为包含ApplicationContext * @param errorList 输出的错误信息List * @param isCache 是否使用Cache中的指令集,建议为true * @param isTrace 是否输出详细的执行指令信息，建议为false * @param aLog 输出的log * @return * @throws Exception */Object execute(String expressString, IExpressContext&lt;String,Object&gt; context,List&lt;String&gt; errorList, boolean isCache, boolean isTrace, Log aLog); 3.3 功能扩展API列表QLExpress主要通过子类实现Operator.java提供的以下方法来最简单的操作符定义，然后可以被通过addFunction或者addOperator的方式注入到ExpressRunner中。1public abstract Object executeInner(Object[] list) throws Exception; 比如我们几行代码就可以实现一个功能超级强大、非常好用的join操作符:list = 1 join 2 join 3; -&gt; [1,2,3] list = join(list,4,5,6); -&gt; [1,2,3,4,5,6]123456789101112131415public class JoinOperator extends Operator&#123; public Object executeInner(Object[] list) throws Exception &#123; java.util.List result = new java.util.ArrayList(); Object opdata1 = list[0]; if(opdata1 instanceof java.util.List)&#123; result.addAll((java.util.List)opdata1); &#125;else&#123; result.add(opdata1); &#125; for(int i=1;i&lt;list.length;i++)&#123; result.add(list[i]); &#125; return result; &#125;&#125; 如果你使用Operator的基类OperatorBase.java将获得更强大的能力，基本能够满足所有的要求。 3.3.1 function相关API12345678910111213141516//通过name获取function的定义OperatorBase getFunciton(String name);//通过自定义的Operator来实现类似：fun(a,b,c)void addFunction(String name, OperatorBase op);//fun(a,b,c) 绑定 object.function(a,b,c)对象方法void addFunctionOfServiceMethod(String name, Object aServiceObject, String aFunctionName, Class&lt;?&gt;[] aParameterClassTypes, String errorInfo);//fun(a,b,c) 绑定 Class.function(a,b,c)类方法void addFunctionOfClassMethod(String name, String aClassName, String aFunctionName, Class&lt;?&gt;[] aParameterClassTypes, String errorInfo);//给Class增加或者替换method，同时 支持a.fun(b) ，fun(a,b) 两种方法调用//比如扩展String.class的isBlank方法:“abc”.isBlank()和isBlank(&quot;abc&quot;)都可以调用void addFunctionAndClassMethod(String name,Class&lt;?&gt;bindingClass, OperatorBase op); 3.3.2 Operator相关API提到脚本语言的操作符，优先级、运算的目数、覆盖原始的操作符(+,-,*,/等等)都是需要考虑的问题，QLExpress统统帮你搞定了。123456789//添加操作符号,可以设置优先级void addOperator(String name,Operator op);void addOperator(String name,String aRefOpername,Operator op); //替换操作符处理OperatorBase replaceOperator(String name,OperatorBase op); //添加操作符和关键字的别名，比如 if..then..else -&gt; 如果。。那么。。否则。。void addOperatorWithAlias(String keyWordName, String realKeyWordName, String errorInfo); 3.3.3 宏定义相关APIQLExpress的宏定义比较简单，就是简单的用一个变量替换一段文本，和传统的函数替换有所区别。12//比如addMacro(&quot;天猫卖家&quot;,&quot;userDO.userTag &amp;1024 ==1024&quot;)void addMacro(String macroName,String express) 3.3.4 java class的相关apiQLExpress可以通过给java类增加或者改写一些method和field，比如 链式调用：”list.join(“1”).join(“2”)”，比如中文属性：”list.长度”。12345//添加类的属性字段void addClassField(String field,Class&lt;?&gt;bindingClass,Class&lt;?&gt;returnType,Operator op);//添加类的方法void addClassMethod(String name,Class&lt;?&gt;bindingClass,OperatorBase op); 注意，这些类的字段和方法是执行器通过解析语法执行的，而不是通过字节码增强等技术，所以只在脚本运行期间生效，不会对jvm整体的运行产生任何影响，所以是绝对安全的。 3.3.5 语法树解析变量、函数的API这些接口主要是对一个脚本内容的静态分析，可以作为上下文创建的依据，也可以用于系统的业务处理。比如：计算 “a+fun1(a)+fun2(a+b)+c.getName()” 包含的变量:a,b,c 包含的函数:fun1,fun21234//获取一个表达式需要的外部变量名称列表String[] getOutVarNames(String express);String[] getOutFunctionNames(String express); 3.3.6 语法解析校验api脚本语法是否正确，可以通过ExpressRunner编译指令集的接口来完成。123String expressString = &quot;for(i=0;i&lt;10;i++)&#123;sum=i+1&#125;return sum;&quot;;InstructionSet instructionSet = expressRunner.parseInstructionSet(expressString);//如果调用过程不出现异常，指令集instructionSet就是可以被加载运行（execute）了！ 3.3.7 指令集缓存相关的api因为QLExpress对文本到指令集做了一个本地HashMap缓存，通常情况下一个设计合理的应用脚本数量应该是有限的，缓存是安全稳定的，但是也提供了一些接口进行管理。1234//优先从本地指令集缓存获取指令集，没有的话生成并且缓存在本地InstructionSet getInstructionSetFromLocalCache(String expressString);//清除缓存void clearExpressCache(); 3.3.8 增强上下文参数Context相关的api - 01与spring框架的无缝集成上下文参数 IExpressContext context 非常有用，它允许put任何变量，然后在脚本中识别出来。在实际中我们很希望能够无缝的集成到spring框架中，可以仿照下面的例子使用一个子类。1234567891011121314151617181920212223242526272829303132333435public class QLExpressContext extends HashMap&lt;String, Object&gt; implements IExpressContext&lt;String, Object&gt; &#123; private ApplicationContext context; //构造函数，传入context和 ApplicationContext public QLExpressContext(Map&lt;String, Object&gt; map, ApplicationContext aContext) &#123; super(map); this.context = aContext; &#125; /** * 抽象方法：根据名称从属性列表中提取属性值 */ public Object get(Object name) &#123; Object result = null; result = super.get(name); try &#123; if (result == null &amp;&amp; this.context != null &amp;&amp; this.context.containsBean((String) name)) &#123; // 如果在Spring容器中包含bean，则返回String的Bean result = this.context.getBean((String) name); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return result; &#125; public Object put(String name, Object object) &#123; return super.put(name, object); &#125;&#125; 完整的demo参照 SpringDemoTest.java 3.3.9 增强上下文参数Context相关的api - 02自定义函数操作符获取原始的context控制上下文自定义的Operator需要直接继承OperatorBase，获取到parent即可，可以用于在运行一组脚本的时候，直接编辑上下文信息，业务逻辑处理上也非常有用。12345678910111213141516171819202122232425262728293031public class ContextMessagePutTest &#123; class OperatorContextPut extends OperatorBase &#123; public OperatorContextPut(String aName) &#123; this.name = aName; &#125; @Override public OperateData executeInner(InstructionSetContext parent, ArraySwap list) throws Exception &#123; String key = list.get(0).toString(); Object value = list.get(1); parent.put(key,value); return null; &#125; &#125; @Test public void test() throws Exception&#123; ExpressRunner runner = new ExpressRunner(); OperatorBase op = new OperatorContextPut(&quot;contextPut&quot;); runner.addFunction(&quot;contextPut&quot;,op); String exp = &quot;contextPut(&apos;success&apos;,&apos;false&apos;);contextPut(&apos;error&apos;,&apos;错误信息&apos;);contextPut(&apos;warning&apos;,&apos;提醒信息&apos;)&quot;; IExpressContext&lt;String, Object&gt; context = new DefaultContext&lt;String, Object&gt;(); context.put(&quot;success&quot;,&quot;true&quot;); Object result = runner.execute(exp,context,null,false,true); System.out.println(result); System.out.println(context); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://bruce.bugmakers.club/categories/java/"}],"tags":[{"name":"awesome","slug":"awesome","permalink":"http://bruce.bugmakers.club/tags/awesome/"},{"name":"规则引擎","slug":"规则引擎","permalink":"http://bruce.bugmakers.club/tags/规则引擎/"}]},{"title":"公开课 | 网易云课堂Java高级开发工程师(持续更新中)","slug":"网易公开课/Java高级工程师公开课","date":"2018-12-11T23:03:00.000Z","updated":"2019-03-01T07:18:20.429Z","comments":true,"path":"2018/12/12/网易公开课/Java高级工程师公开课/","link":"","permalink":"http://bruce.bugmakers.club/2018/12/12/网易公开课/Java高级工程师公开课/","excerpt":"","text":"网易云课堂Java高级开发工程师公开课索引第一期 Java高级开发工程师直播公开课 《Java高级开发工程师》直播课 《Java高级开发工程师》直播课Ⅲ 《Java高级开发工程师》直播课Ⅳ 《Java高级开发工程师》直播课Ⅴ 《Java高级开发工程师》直播课Ⅵ 《Java高级开发工程师》直播课Ⅶ 第二期 Java高级开发工程师直播课1 Java高级开发工程师直播课2 Java高级开发工程师直播课3 Java高级开发工程师直播课4 课程 内容简介 海报 offer收割机-互联网公司技术类面试技巧2019-02-22 1.揭开java班主任的神秘面纱2.网易技术大佬带你优化简历3.一个程序员面试的自我修养4.网易研发人员招聘需求分析 搞定多线程核心知识-从线程安全原子性到Lock锁接口的实现2019-02-21 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密4、JAVA高并发并发编程知识体系梳理； 资深JAVA面试题-60分钟搞透分布式一致性hash算法2019-02-20 60分钟搞透分布式一致性hash算法 P8架构师分享-10亿级负载均衡架构2019-02-19 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高并发/高可用/分布式等热门技术学习路线 网易技术面试题-高性能NIO编程详解2019-02-18 1、 BIO和NIO区别搞懂了嘛？2、 NIO支撑海量连接的原理大剖析3、 什么情况下用BIO，什么情况下用NIO？4、 高性能网络编程的正确学习姿势 大型互联网分布式系统-架构演进之路2019-01-29 大型互联网分布式系统 - 架构演进之路 高性能系统优化之请求合并让性能提升数十倍2019-01-27 1、 缓存并不是系统优化的唯一手段2、 合并多个用户的请求，发挥批量处理的高性能优势3、 利用JAVA多线程技术，实现性能倍增 让技术不再生涩难懂-Spring+事务，原理就是这么简单2019-01-26 1、清晰理解分布式事务之困难2、不要再答不出两阶段提交-XA规范3、彻底搞清楚JTA是什么4、分布式事务不再难，熟练掌握Spring中JTA的使用！ SpringBoot让你的代码更优雅-彻底搞懂auto-configuration2019-01-25 1、spring boot 参数配置与使用2、如何让配置与程序分离——你必须知道的spring boot参数配置规则3、如何在你的代码中方便的使用配置参数4、关于spring boot … 从Spring中学习设计模式这三个步骤让你你熟练运用设计模式2019-01-24 1、前人总结的那些代码设计原则2、识别代码中那些“坏味道”3、通过设计模式来改进你的代码4、Spring框架源码中那些设计模式 挑战JDK源码面试-J.U.C并发编程工具类原理学习2019-01-23 1、 3W1H学习方法分享2、 如何用多线程优化你的业务代码；3、知其然也要知其所以然，线程技术原理剖析；4、JAVA多线程并发编程学习路线图； 你不知道的线程池原理分析和API解读2019-01-22 上万并发的程序设计中，开多少线程合适？知其所以然-线程池原理揭秘如何正确使用JAVA并发包中的线程池APIJAVA高并发并发编程知识体系梳理 SpringBoot极速开发-360度无死角揭秘Starter机制2019-01-21 starter让开发变得如此简单starter原理揭秘开发自己的starter直播讲师：mike 架构师全方位剖析，10亿级访问量网站的负载均衡架构2019-01-20 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高并… 5年JAVA开发，被这道Redis面试题筛下来Redis底层探秘之旅2019-01-19 1、 Redis经典面试题分享；2、 Redis原理学习方式；3、 带你自己实现Redis的JAVA客户端；4、 拓展：Redis主从复制原理浅析5、 Redis中蕴藏着的那些分布式系… 带你搞定多线程-并发编程之volatile关键字2019-01-18 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密4、JAVA高并发并发编程知识体系梳理； 饿了么外卖场景，分布式事务解决方案实录2019-01-17 1. 隐藏在业务场景中的分布式事务问题；2. 分布式事务处理的核心理念3. 如何真正将分布式事务技术落地4. 实战：结合外卖项目下单分单场景解决事务问题5. 分… BAT技术分析，前后端分离架构技术内幕2019-01-16 1、 互联网技术细分的背景下，“大前端”的概念;2、 前后端分离下，用户状态校验方式的调整;3、 4个步骤带你掌握动静分离核心技能；4、 跨域问题最简解决方案… 缓存失效导致系统挂掉！如何解决这个深坑2019-01-15 1、 缓存与高并发这对好基友；2、缓存使用，设计不当导致的隐性问题；3、针对具体问题，详解多种解决方案；4、系统架构没有银弹，高并发系统开发核心理念梳理… 大型系统设计核心之一-分布式订单号生成策略2019-01-14 1、 大型分布式系统下，订单号生成要求2、 主流生成策略逐个讲解3、 多种方案之如何进行技术选型4、 给你做互联网分布式系统开发技术路线规划 还搞不懂Tomcat原理就晚了-带你从零手写Tomcat2019-01-13 1、 Tomcat宏观概念梳理2、 实现Tomcat的具体步骤3、 90分钟写一个能部署war包的tomcat 基于Redis的分布式锁实现方案2019-01-12 1、 锁的概念2、 分布式锁的应用场景3、 Redis实现分布式锁的步骤4、 分布式技术和多线程安全技术知识点梳理 90分钟掌握分布式锁应用与实现2019-01-11 1、3W1H学习方法，为什么需要分布式锁？2、分布式锁的实现方式有哪些？3、基于zookeeper的分布式锁如何实现；4、互联网分布式系统架构技能分享； 安全架构之Https，让你的隐私数据不再暴露2019-01-10 1、 安全之殇 - 分享互联网安全问题2、 Https是如何解决这个问题的3、 信息加密技术剖析4、 教你搭建生产环境上的https环境 BAT大型分布式系统-架构演进之路2019-01-09 1、大型互联网系统架构演进过程2、大型互联网系统架构核心技术3、架构演进思想总结4、架构设计误区 从容应对亿级大数据存储-分库分表技术实战2019-01-08 1、 数据量太多，SQL查询慢怎么办？2、 数据库分库分表概念详解3、 Mycat分布式数据库中间件介绍4、 手把手教你学会用Mycat应对海量数据。 分布式系统开发实战篇-TCC分布式事务实现2018-12-28 1、 分布式系统下高难度的事务问题分析2、 生产级解决方案思路分析3、 老司机手把手分析TCC具体实现过程4、 网易内部JAVA技术栈分析 思维决定高度-老司机和你说说高并发系统开发那些套路2018-12-27 1、三思后行，搞懂高并发核心思路；2、实战分析电商经典高并发应用场景3、架构有方法之从流量角度出发来演进架构4、高并发系统开发常用到的那些中间件 听完这堂手写SpringMVC直播课，硬刚Spring原理面试题2018-12-26 1、 SpringMVC核心处理流程梳理2、 实现一个自己的mvc框架3、 总结技巧，Spring原理不再难懂 多线程面试题系列（一）2018-12-25 1、 如何学习多线程？2、 线程状态3、 线程中止4、 线程通信 让你的数据库抗更大的压力-读写分离从设计到实现2018-12-24 1、 数据库压力太大，如何优化？2、 什么是读写分离？3、 实现读写分离的那些解决方案；4、 60分钟带你实现数据读写分离； 带你搞定多线程-并发编程之volatile关键字2018-12-23 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密；4、JAVA高并发并发编程知识体系梳理； 互联网分布式系统核心组件-详解ELK日志管理体系2018-12-22 1、 单独的日志文件不再适应分布式系统2、 一种满足日志管理、线上问题分析的解决方案3、 老司机手把手分析企业级日志管理方案ELK具体实现4、 网易内部JAVA技… 挑战JDK源码面试-J.U.C并发编程工具类原理学习2018-12-21 1、 3W1H学习方法分享2、 如何用多线程优化你的业务代码；3、知其然也要知其所以然，线程技术原理剖析；4、JAVA多线程并发编程学习路线图； 高并发流量削峰-这么做让系统性能提升50倍以上2018-12-20 1、 高并发流量下，系统故障真实演练2、 应对高并发场景的方式3、 分布式消息中间件Rabbitmq工作流程剖析4、 通过Rabbitmq实现高并发流量削峰性能提升 从Spring中学习设计模式这三个步骤让你你熟练运用设计模式2018-12-19 1、前人总结的那些代码设计原则2、识别代码中那些“坏味道”3、通过设计模式来改进你的代码4、Spring框架源码中那些设计模式 一线互联网公司全方位监控架构-构建分布式调用链路追踪系统2018-12-18 1、大型分布式项目链路监控该如果架构 2、分布式调用链的原理剖析 3、SkyWalking实现分布式链路跟踪 搞懂JMM内存模型就是今晚的事2018-12-17 1、 了解JAVA运行时数据区2、 搞懂堆内存和线程栈的区别3、 JAVA堆内存模型详解 高性能缓存可靠性设计-Redis高可用集群实战2018-12-16 1、了解单实例redis带来的问题 2、redis主从架构搭建 3、大型互联网公司redis高可用方法 4、redis哨兵模式实现高可用 Hystrix请求合并,让性能瞬间提升十倍2018-12-15 1、 缓存并不是系统优化的唯一手段2、 合并多个用户的请求，发挥批量处理的高性能优势3、 利用JAVA多线程技术，实现性能倍增 大型系统设计核心之一分布式订单号生成策略2018-12-14 1、 大型分布式应用中，对业务编号的要求；2、 实现单号生成器的几种方式；3、 架构师技术选型工作之多种方案对比； JDK源码就该这么学-从框架设计者角度学习HashMap2018-12-13 1、 老司机分析源码学习的方法2、 提升自己的思维，从设计者的角度看待问题3、 HashMap源码分析4、 常用JDK工具类源码学习路线 10年老司机开车-60分钟掌握分布式锁应用与实现2018-12-12 1、3W1H学习方法，为什么需要分布式锁？2、分布式锁的实现方式有哪些？3、基于zookeeper的分布式锁如何实现；4、互联网分布式系统架构技能分享； 架构师全方位剖析，10亿级访问量网站的负载均衡架构2018-12-11 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高并… 实战问题解决方案-高性能集群session共享2018-12-10 1、传统单体项目演进集群部署后遇到的问题；2、利用nginx反向代理和负载均衡搭建集群环境；3、集群下session共享原理剖析及解决方法； 支持海量并发连接的秘密-NIO高性能编程实战课2018-12-09 1、 BIO和NIO区别搞懂了嘛？2、 NIO支撑海量连接的原理大剖析3、 什么情况下用BIO，什么情况下用NIO？4、 高性能网络编程的正确学习姿势 分布式系统架构核心组件-统一配置中心2018-12-08 1、传统项目配置管理无法适应分布式系统架构2、 分布式统一配置中心核心概念分析3、 从实际场景出发，解决你的分布式系统难题 一个缓存设计的漏洞，让系统瞬间宕机2018-12-07 1、 高并发下，你的缓存设计真能抗住高并发？2、 详解一个黑客攻击的惯用手法；3、 这几种方案助你真正完善的缓存系统；4、 JAVA缓存架构整体知识图谱； 从容应对亿级大数据存储-分库分表技术实战2018-12-06 1、 数据量太多，SQL查询慢怎么办？2、 数据库分库分表概念详解；3、 Mycat分布式数据库中间件介绍；4、 手把手教你学会用Mycat应对海量数据； 缓存失效导致系统挂掉！如何解决这个深坑2018-12-05 1、缓存与高并发这对好基友；2、 缓存使用，设计不当导致的隐性问题；3、 针对具体问题，详解多种解决方案；4、系统架构没有银弹，高并发系统开发核心理念梳… 安全架构之Https，让你的隐私数据不再暴露2018-12-04 1、 安全之殇 - 分享互联网安全问题2、 Https是如何解决这个问题的3、 信息加密技术剖析4、 教你搭建生产环境上的https环境 最热门分布式技术：dubbo-rpc核心原理剖析2018-12-03 1、 为什么要用dubbo框架2、 dubbo框架本质是什么？3、 手把手带你写出dubbo核心逻辑4、 Dubbo完整知识体系梳理 基于Redis的分布式锁实现方案2018-12-02 1、 锁的概念2、 分布式锁的应用场景3、 Redis实现分布式锁的步骤4、 分布式技术和多线程安全技术知识点梳理 分布式系统RPC技术核心之TCP粘包拆包解决方案2018-12-01 1、 RPC技术分析2、 netty框架5分钟上手使用3、 网络知识快速掌握4、 每个RPC都必须解决的粘包拆包问题 代码优雅系列之手写注解2018-11-30 1、 如何从繁琐的业务代码中解脱？2、 学习Spring等顶级框架的代码设计；3、 15分钟了解注解内部原理；4、 手把手带你进行业务代码封装； 还搞不懂Tomcat原理就晚了-带你从零手写Tomcat2018-11-29 1、 Tomcat宏观概念梳理2、 实现Tomcat的具体步骤3、 90分钟写一个能部署war包的tomcat 分布式系统session共享机制全方位剖析2018-11-28 1、应对海量请求之快速构建应用集群2、session一致性问题剖析3、常用session共享解决方案介绍 高并发缓存架构之服务器代理缓存2018-11-27 1、 海量读取请求，数据库性能分析2、 巧妙利用http协议实现缓存3、 高性能缓存之Nginx高级特性的使用4、 互联网缓存架构整体技术剖析 不懂源码必看之作：手写springmvc2018-11-26 1、 SpringMVC核心处理流程梳理2、 实现一个自己的mvc框架3、 总结技巧，Spring原理不再难懂 5年JAVA开发，被这道Redis面试题筛下来Redis底层探秘之旅2018-11-25 1、 Redis经典面试题分享；2、 Redis原理学习方式；3、 带你自己实现Redis的JAVA客户端；4、 拓展：Redis主从复制原理浅析；5、 Redis中蕴藏着的那些分布式… 轻松搞定数据库读写分离2018-11-24 1、 数据库压力太大，如何优化？2、 什么是读写分离？3、 实现读写分离的那些解决方案。4、 30分钟带你实现数据读写分离 揭开JAVA热加载神秘面纱-Tomcat在用的热加载方案2018-11-23 1、JAVA程序运行过程梳理；2、手把手带你实现不重启JVM，执行最新修改代码；3、 验证Tomcat内部热加载功能的实现原理 高并发流量削峰-系统性能瞬间提升50倍以上2018-11-22 1、 高并发流量下，系统故障真实演练2、 应对高并发场景的方式3、 分布式消息中间件Rabbitmq工作流程剖析4、 通过Rabbitmq实现高并发流量削峰性能提升 架构师全方位剖析，10亿级访问量网站的负载均衡架构2018-11-21 1、抗住海量请求的大杀器：水平扩展2、云平台商用级负载均衡产品内部组成原理揭秘3、架构理论 + 落地实现，手把手教你搭建大型网站负载均衡模型4、拓展：高… 从容应对亿级大数据存储-分库分表技术实战2018-11-20 1、 数据量太多，SQL查询慢怎么办？2、 数据库分库分表概念详解3、 Mycat分布式数据库中间件介绍4、 手把手教你学会用Mycat应对海量数据。。 JDK源码学习有方法！J.U.C并发编程工具类原理剖析2018-11-19 1、 3W1H学习方法分享2、 如何用多线程优化你的业务代码；3、知其然也要知其所以然，线程技术原理剖析；4、JAVA多线程并发编程学习路线图。 BAT技术分析，前后端分离架构技术内幕2018-11-18 1、 互联网技术细分的背景下，“大前端”的概念;2、 前后端分离下，用户状态校验方式的调整;3、 4个步骤带你掌握动静分离核心技能；4、 跨域问题最简解决方案… 压榨数据库极致性能-Mysql数据库优化及SQL优化2018-11-17 1、 MySQL在使用中常见性能瓶颈分析2、 EXPLAIN执行计划语句的原理讲解3、 索引的实际应用与注意事项4、 对Mysql进行缓存，I/O，通信等调优 电商系统核心技术内幕-高并发订单号生成策略揭秘2018-11-16 1、 大型分布式系统下，订单号生成要求2、 主流生成策略逐个讲解3、 多种方案之如何进行技术选型4、 给你做互联网分布式系统开发技术路线规划 带你搞定多线程-并发编程之volatile关键字2018-11-15 1、多线程并发中的变量可见性是怎么一回事？2、线程安全问题的根本原因是什么？3、volatile关键字解密4、JAVA高并发并发编程知识体系梳理； 饿了么外卖场景，分布式事务解决方案实录2018-11-14 1. 隐藏在业务场景中的分布式事务问题；2. 分布式事务处理的核心理念3. 如何真正将分布式事务技术落地4. 实战：结合外卖项目下单分单场景解决事务问题5. 分… 电商系统和分布式消息中间件，不得不说的故事2018-11-13 1、 经典电商业务场景详解2、 分布式消息中间件RabbitMQ核心概念梳理；3、 电商系统中MQ中间件的架构设计图一览；4、 必看的几个电商业务设计关键点； 【实战篇】Spring框架源码中的设计模式2018-11-12 1、前人总结的那些代码设计原则2、识别代码中那些“坏味道”3、通过设计模式来改进你的代码4、Spring框架源码中那些设计模式 大型互联网分布式系统架构演进之路2018-11-11 大型互联网系统架构演进过程大型互联网系统架构核心技术架构演进思想总结架构设计误区 高并发秒杀系统架构设计和实现2018-11-10 1、三思后行，搞懂高并发核心思路；2、实战分析电商经典高并发应用场景3、架构有方法之从流量角度出发来演进架构4、高并发系统开发常用到的那些中间件 120分钟掌握分布式锁应用与实现2018-11-09 1、3W1H学习方法，为什么需要分布式锁？2、分布式锁的实现方式有哪些？3、基于zookeeper的分布式锁如何实现；4、互联网分布式系统架构技能分享； 缓存失效导致系统挂掉！如何解决这个深坑2018-11-08 1. 缓存与高并发这对好基友；2. 缓存使用，设计不当导致的隐性问题；3. 针对具体问题，详解多种解决方案；4. 系统架构没有银弹，高并发系统开发核心理念梳理","categories":[{"name":"JAVA高级","slug":"JAVA高级","permalink":"http://bruce.bugmakers.club/categories/JAVA高级/"}],"tags":[{"name":"公开课","slug":"公开课","permalink":"http://bruce.bugmakers.club/tags/公开课/"}]},{"title":"vue | VUE组件 - 回到顶部","slug":"vue/vue组件 - 回到顶部","date":"2018-06-14T12:12:00.000Z","updated":"2019-01-08T15:07:02.751Z","comments":true,"path":"2018/06/14/vue/vue组件 - 回到顶部/","link":"","permalink":"http://bruce.bugmakers.club/2018/06/14/vue/vue组件 - 回到顶部/","excerpt":"","text":"组件效果图 组件使用示例 backTopDemo.vue1234567891011121314151617&lt;template&gt; &lt;div style=&quot;height: 2000px;&quot;&gt; &lt;back-top&gt;&lt;/back-top&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BackTop from &apos;../components/common/backTop&apos;export default &#123; name: &apos;backTopDemo&apos;, components: &#123;BackTop&#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 组件源码 backTop.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;transition name=&apos;slide-fade&apos;&gt; &lt;div class=&apos;page-component-up&apos; v-if=&apos;isShow&apos; @click=&apos;getTop&apos;&gt; &lt;i class=&quot;el-icon-caret-top&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;BackTop&apos;, data () &#123; return &#123; isShow: false &#125; &#125;, methods: &#123; // 添加样式，鼠标hover上去，改变颜色 addhoverClass (e) &#123; if (e.type === &apos;mouseover&apos; &amp;&amp; this.$el.classList) &#123; this.$el.classList.add(&apos;hover&apos;) &#125; else if (e.type === &apos;mouseout&apos; &amp;&amp; this.$el.classList) &#123; this.$el.classList.remove(&apos;hover&apos;) &#125; &#125;, showIcon () &#123; if (document.documentElement.scrollTop &gt; 100) &#123; this.isShow = true this.$el.addEventListener(&apos;mouseover&apos;, this.addhoverClass) this.$el.addEventListener(&apos;mouseout&apos;, this.addhoverClass) &#125; else if (document.documentElement.scrollTop &lt; 100) &#123; this.isShow = false &#125; &#125;, getTop () &#123; let timer = setInterval(() =&gt; &#123; let top = document.documentElement.scrollTop let speed = Math.ceil(top / 5) document.documentElement.scrollTop = top - speed if (top === 0) &#123; clearInterval(timer) &#125; &#125;, 20) &#125; &#125;, mounted () &#123; window.addEventListener(&apos;scroll&apos;, this.showIcon) &#125;, beforeDestroy () &#123; window.removeEventListener(&apos;scroll&apos;, this.showIcon) &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; rel=&quot;stylesheet/scss&quot;&gt;.slide-fade-enter-active &#123; transition: all .1s ease;&#125;.slide-fade-leave-active &#123; transition: all .1s cubic-bezier(1.0, 0.3, 0.8, 1.0); opacity: 0;&#125;.slide-fade-enter, .slide-fade-leave-to /* .slide-fade-leave-active 在低于 2.1.8 版本中 */ &#123; // transform: translateY(-20px); opacity: 0;&#125;.page-component-up &#123; background-color: #67C23A; position: fixed; right: 3rem; bottom: 8rem; width: 50px; height: 50px; border-radius: 25px; cursor: pointer; opacity: .3; transition: .3s; text-align: center; z-index: 999;&#125;.el-icon-caret-top &#123; font-size: 36px; margin-top: 7px; color: #FFFFFF; text-align: center; z-index: 1000&#125;.hover &#123; background-color: #409EFF;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://bruce.bugmakers.club/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/tags/前端/"}]},{"title":"vue | VUE - 教程收集","slug":"vue/vue基础","date":"2018-05-30T02:33:00.000Z","updated":"2019-01-08T15:07:02.766Z","comments":true,"path":"2018/05/30/vue/vue基础/","link":"","permalink":"http://bruce.bugmakers.club/2018/05/30/vue/vue基础/","excerpt":"","text":"主要内容整理自前端君的微信公众号：web前端教程，本文仅做个内容一览和跳转（跳转到原作者公众号文章） 最新更新：无论学习什么，多从官网渠道获取信息，vue中文官网：https://cn.vuejs.org/index.html VUE 基础：《vue2.0基础系列》目录大全 进阶：《vue2.0进阶系列》 ES 6前端君除了vue教程外，还做了es6的系列教程，vue是基于es开发的，所以学习es也是蛮有必要的，至于es是什么，自行学习哈 ES6：《ES6系列连载》 其他一个前端的在线文档：http://docs.720ui.com/api_docs_web.html","categories":[{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://bruce.bugmakers.club/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://bruce.bugmakers.club/tags/前端/"}]},{"title":"tools | 推荐一款本地文件检索工具：Launchy","slug":"tools/tools-launchy","date":"2018-04-25T14:10:00.000Z","updated":"2019-01-08T15:07:02.651Z","comments":true,"path":"2018/04/25/tools/tools-launchy/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/25/tools/tools-launchy/","excerpt":"","text":"1、演示 2、优点 轻量级，安装后占用空间才10+MB 操作简单，体验很好 免费 3、下载地址http://www.launchy.net/download.php#windows","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"tools | 推荐一款漂浮截图工具：SETUNA","slug":"tools/tools-setuna","date":"2018-04-23T05:10:00.000Z","updated":"2019-01-08T15:07:02.666Z","comments":true,"path":"2018/04/23/tools/tools-setuna/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/23/tools/tools-setuna/","excerpt":"","text":"1、演示 2、优点 轻量级，整个软件大小只有1.17MB 操作简单，体验很好 免费 3、下载地址 我的百度云 https://pan.baidu.com/s/1UKG2zZ0CYVOwBJQGy21C4w 类似小工具1）pureref，官网：https://www.pureref.com/ 推荐文章：https://cloud.tencent.com/developer/news/44018","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"tools | 推荐一款gif录制工具：LICEcap","slug":"tools/tools-liceecap","date":"2018-04-21T15:30:00.000Z","updated":"2019-01-08T15:07:02.738Z","comments":true,"path":"2018/04/21/tools/tools-liceecap/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/21/tools/tools-liceecap/","excerpt":"","text":"1、演示 2、优点 轻量级，整个软件大小只有1.17MB 操作简单，体验很好 免费 3、下载地址 官网 https://www.cockos.com/licecap/ 我的github仓库 https://github.com/BruceOuyang/issuelist/blob/master/tools/licecap126-install.zip 我的百度云 https://pan.baidu.com/s/13dNnFKf1ASq7ysMBjfcY4w","categories":[{"name":"工具","slug":"工具","permalink":"http://bruce.bugmakers.club/categories/工具/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://bruce.bugmakers.club/tags/效率/"}]},{"title":"设计模式 | 开篇","slug":"design-pattern/00-boy-learning-design-pattern","date":"2018-04-19T23:13:00.000Z","updated":"2019-01-06T17:34:44.194Z","comments":true,"path":"2018/04/20/design-pattern/00-boy-learning-design-pattern/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/20/design-pattern/00-boy-learning-design-pattern/","excerpt":"","text":"Bruce Ouyang 正在学习《设计模式Java版》 http://woquanke.com/books/gof/这本书个人学习的主要内容以及对应源码记录在https://github.com/BruceOuyang/boy-design-pattern目录下 初衷 系统的学习一遍设计模式 书的原链接https://gof.quanke.name 这个地址貌似正常情况下访问不了，习惯了markdown不想去看csdn上旧风格的文章（quanke大神的csdn博客上也有一份设计模式）,故在此仓库copy一份，方便大家访问和一起学习 最新更新，原作者提供了新域名访问地址： http://woquanke.com/books/gof/ ，国内访问无压力 融入一点自己的风格：我将刘伟大神的设计模式一书内容分散在代码的各个包里边，方便阅读 原文中有一些练习，就在这个仓库的源码中做掉 二十四种设计模式一览 以下文章持续更新中… 创建型 六个创建型模式 SEQ1 - 简单工厂模式 Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 SEQ2 - 工厂方法模式 Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】 SEQ3 - 抽象工厂模式 Abstract Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】 SEQ4 - 单例模式 Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 SEQ5 - 原型模式 Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ6 - 建造者模式 Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】 结构型 七个结构型模式 SEQ1 - 适配器模式 Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】 SEQ2 - 桥接模式 Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ3 - 组合模式 Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 SEQ4 - 装饰模式 Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ5 - 外观模式 Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】 SEQ6 - 享元模式 Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 SEQ7 - 代理模式 Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 行为型 十一个行为型模式 SEQ01 - 职责链模式 Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 SEQ02 - 命令模式 Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】 SEQ03 - 解释器模式 Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】 SEQ04 - 迭代器模式 Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 SEQ05 - 中介者模式 Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】 SEQ06 - 备忘录模式 Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】 SEQ07 - 观察者模式 Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】 SEQ08 - 状态模式 State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】 SEQ09 - 策略模式 Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】 SEQ10 - 模板方法模式 Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】 SEQ11 - 访问者模式 Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】 复习 设计模式趣味学习 设计模式于足球 设计模式综合应用实例 多人联机射击游戏 数据库同步服务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://bruce.bugmakers.club/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://bruce.bugmakers.club/tags/设计模式/"}]},{"title":"免费博客 | Hexo搭建博客并部署到Github Pages服务","slug":"hexo/hexo-githubpages-blog","date":"2018-04-19T14:05:00.000Z","updated":"2019-01-08T15:07:02.688Z","comments":true,"path":"2018/04/19/hexo/hexo-githubpages-blog/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/19/hexo/hexo-githubpages-blog/","excerpt":"","text":"本文实践的操作系统是windows 10，其他OS的可以当做参考用 一、Hexo搭建博客1. 环境准备 下载并安装 nodejs 下载并安装 git 直接上官网看指引即可，如有疑问可以在评论中留言说明 2. Hexo初始化博客 在命令行窗口中执行下列命令 使用npm安装hexo 1npm install -g hexo-cli 初始化你的博客项目 执行命令123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install &lt;folder&gt; 是你本地的文件目录，例如：F:\\bruce\\hexo\\bugmakerBlog，如果不写，则会在执行命令的当前目录初始化一个hexo博客项目 初始化的过程中会去github上下载一些东西，比如说默认的主题 landscape 之类的，需要等个几分钟 初始化完成后，你会得到一个这样的项目目录结构： _config.yml网站的主要配置文件，可以配置你网站的大部分信息。【配置参考说明】 简单的配置示例 key 说明 示例 title 网站的名字 BuG制造者联盟官方主页 author 网站的作者 Bruce language 语言设置 zh-CN package.json应用数据。 scaffolds目录模板目录，你新建一篇博客的时候会以这个目录中的模板文件来创建。 source目录资源目录，你新建的博客都存储在这里。在生成页面的时候，hexo会忽略掉命名为 _ 开头的文件或文件夹， _post 除外，会将 .md 和 .html 后缀的文件按主题生成页面，并复制到public目录下，其他后缀的文件则直接复制过去，不进行额外转换操作。 themes目录主题目录，你可以为自己的网站挑选好看的主题，然后在 _config.yml 文件中指定主题即可。 写一篇博客1hexo new [layout] &lt;title&gt; hexo new 会在 source目录 中创建一个以 &lt;title&gt; 命名的 .md 文件[layout] 是默认布局，在 scaffolds目录 下定义的，默认布局在 _config.yml 中指定，初始化的默认布局是 post&lt;title&gt; 是博客的标题，博客的标题可以在生成的 .md 文件中修改 示例1hexo new post My First Blog 生成页面并运行你的博客12hexo ghexo s -p 80 hexo g 是hexo生成页面指令 hexo generate 的缩写hexo s 是hexo启动本地服务的指令，默认端口是4000-p 80 是指定端口号80 默认访问地址 http://localhost:4000指定80端口访问地址 http://localhost 3. 切换博客主题在上一步中，我们看到的博客使用的主题是默认的 landscape 主题，hexo为我们提供了很多的主题可以选择，访问网站 https://hexo.io/themes/ 挑选自己喜欢的主题 将挑选好的主题 clone 到 theme目录 下，主题目录下也有一个 _config.yml 配置文件，这个配置文件即主题相关配置，具体根据主题的wiki上的说明来操作 在 _config.yml 中，设置 theme 属性的值为 theme目录 下的某一款主题即可，直接写目录下的文件夹名字 示例： clone主题到 theme目录 1git clone https://github.com/klugjo/hexo-theme-alpha-dust.git 修改根目录下的 _config.yml 配置文件，设置 theme 值 1theme : hexo-theme-alpha-dust 重新生成并启动本地服务 12hexo ghexo s -p 80 效果图 二、了解Github Pages服务GitHub Pages 网站：https://pages.github.com/ 1. 有什么用 Websites for you and your projects. 为你和你的项目提供一个网站Hosted directly from your GitHub repository. 直接托管存储在你的github仓库Just edit, push, and your changes are live. 只管去编辑提交代码到仓库，你的网站都会即时更新。 2. 怎么玩的 步骤其实很简单，在 Github Pages上都有如果你还没有github的账号，那需要先注册一个 第一步：在github上创建一个仓库，命名为 username.github.io username就是你的github用户名，注意不是登录账号，我仓库名字是 BuGMakerClub.github.io 第二步：将刚刚创建的仓库 clone 到本地，如 F:\\bruce\\bruce-private-github\\BuGMakerClub.github.io 12cd F:\\bruce\\bruce-private-github\\git clone https://github.com/BuGMakerClub/BuGMakerClub.github.io.git 第三步：在 clone 下来的项目中，创建一个 index.html，内容可以是 Hello World 12cd BuGMakerClub.github.ioecho &apos;Hello World&apos; &gt; index.html 第四步：提交代码，把刚创建的 index.html 文件 commit &amp; push 到你的 github仓库中 第五步：结束，你可以直接访问 https://username.github.io 访问你的网站了，我的网站地址是 https://BuGMakerClub.github.io 第六步：设置自己的个性化域名 如果你有自己的域名，可以在仓库的设置中绑定自己的个性化域名，然后在域名管理中心设置一个域名解析地址，这样就可以用个性化域名来访问github pages服务商的网页了 三、结合Hexo博客和Github Pages服务 参考：https://hexo.io/docs/deployment.html hexo的配置中，有一个 deploy 指令，可以将生成的博客网站部署到github仓库中，这样就形成两者的结合关系了。 具体操作如下 安装 hexo-deployer-git 插件1npm install hexo-deployer-git --save 修改根目录下的 _config.yml 配置文件 123deploy: type: git repo: https://github.com/BuGMakerClub/BuGMakerClub.github.io.git 执行 deploy 指令发布代码 1hexo d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/categories/hexo/"}],"tags":[{"name":"免费博客","slug":"免费博客","permalink":"http://bruce.bugmakers.club/tags/免费博客/"},{"name":"github pages","slug":"github-pages","permalink":"http://bruce.bugmakers.club/tags/github-pages/"}]},{"title":"免费博客 | Hello Hexo","slug":"hexo/hello-world","date":"2018-04-18T21:05:00.000Z","updated":"2019-01-08T15:07:02.709Z","comments":true,"path":"2018/04/19/hexo/hello-world/","link":"","permalink":"http://bruce.bugmakers.club/2018/04/19/hexo/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://bruce.bugmakers.club/tags/hexo/"},{"name":"免费博客","slug":"免费博客","permalink":"http://bruce.bugmakers.club/tags/免费博客/"}]},{"title":"敏捷开发 | Scrum 实践分享","slug":"agile/敏捷开发","date":"2017-08-15T02:00:00.000Z","updated":"2019-04-24T09:18:29.364Z","comments":true,"path":"2017/08/15/agile/敏捷开发/","link":"","permalink":"http://bruce.bugmakers.club/2017/08/15/agile/敏捷开发/","excerpt":"","text":"1 scrum processresource：Scrum介绍-LukeShen.pptx 2 daily meeting info collector resource：sprint-standmeeting-demo.xls","categories":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://bruce.bugmakers.club/categories/敏捷开发/"}],"tags":[{"name":"敏捷开发","slug":"敏捷开发","permalink":"http://bruce.bugmakers.club/tags/敏捷开发/"},{"name":"Scrum","slug":"Scrum","permalink":"http://bruce.bugmakers.club/tags/Scrum/"}]}]}